---
title: 02软件开发方法及过程模型
date: 2023-04-26
author: LM
---

# 1.结构化开发方法

## 1.1 结构化分析

- 结构化分析（SA）是指20世纪70年代末，由 Demarco 等人提出的，面向数据流进行需求分析的方法，旨在减少分析活动中的错误，建立满足用户需求的系统逻辑模型。
- 结构化分析的要点是：根据软件内部数据传递、变换的关系，采用自顶向下，逐层分解的方法，经过一系列分解和抽象，建立系统的逻辑模型，将软件系统抽象为一系列的逻辑加工单元，各单元之间以数据流发生关联。
- 结构化分析是软件工程中最早出现的开发方法，特别适合于数据处理领域的问题，但是不适合解决大规模的、特别复杂的项目，且难以适应需求的变化。
- 结构化分析的输出包括数据流图，数据字典以及对应的加工逻辑。

## 1.2 结构化设计

![](/images/drawingbed/img/202307040937993.png)

## 1.3 结构化方法

- 结构化方法的指导思想是：自顶向下、逐层分解，它的基本原则是功能的分解与抽象。
- 使用数据流图来描述系统由哪几部分组成，各部分之间有什么联系。
- 使用数据字典来定义各种数据，说明数据流图中每一个图形元素。
- 使用加工规格说明（结构化语言、判定表、判定树）来描述算法逻辑，说明数据流图中不能被再分解的每一个加工。

## 1.4 结构化建模

- **数据流图（DFD）**：功能建模，其要素包括加工，数据流，是需求分析阶段的结果，是接口设计的依据。
- **实体联系图（E-R）**：数据建模，其要素包括实体类型，属性和联系的方法，是描述现实世界的概念模型。
- **状态-迁移图（STD）**：行为建模，其要素包括状态，改变状态的事件，用来描述系统的行为。

## 1.5 结构化开发工具

### 1.5.1 数据字典

- 数据字典是一个存放有数据库所用的有关信息，在数据库设计的初期将数据库中的各类数据的描述集合在一起，用于在开发，维护或者其他需要的时候使用，可以类比成我们现实中的字典。
- 数据字典通常包括：数据项，数据结构，数据流，数据存储，基本加工。
- 数据项是数据的最小组成单位，若干个数据项可以组成一个数据结构。数据字典通过对数据项和数据结构的定义来描述数据流和数据存储的逻辑内容。

### 1.5.2 数据流图

- 数据流图（Data Flow Diagram），简称 DFD，它从数据传递和加工角度，以图形方式来表达数据在系统内部的逻辑流向和逻辑变换过程，是结构化系统分析方法的主要表达工具及用于表示软件模型的一种图示方法。
- 数据流图反映了系统必须完成的逻辑功能，用于功能建模。
- 数据流图是接口设计的依据。
- 数据流图具有抽象性，概括性的特征。
- 数据流图的平衡指父图和子图的输入，输出数据流的一致性。

#### 1.5.1.1 数据流图的四要素

- 外部实体：方框表示，指系统之外与系统有联系的人或事物，表示该系统数据的外部来源和去处。
- 数据加工：椭圆表示，描述输入数据流到输出数据之间的变换，也就是输入数据流经过什么处理后变成了输出数据。可以使用结构化语言，判定表和判定树来进行描述。
- 数据存储：使用一组平行线表示，某种数据保存后的逻辑统称，不是指保存数据的物理地点和物理介质。每个数据存储都有一个名字。
- 数据流：使用带箭头的曲线表示，处理功能的输入 / 输出，箭头表示数据流向。

#### 1.5.1.2 数据流图的层次

- 顶层图（第0层）只有代表整个软件系统的1个加工，描述了软件系统与外界之间的数据流
- 顶层图中的加工经分解后的图称为第1层图(只有1张)
- 中间层图中至少有一个加工(也可以有多个)在下层图中分解成一张子图
- 处于最底层的图称为底层图，其中所有的加工不再分解成新的子图

#### 1.5.1.3 数据流图的注意事项

- 自外向内，自顶向下，逐层细化，完善求精。
- 必须保持父图与子图的平衡。
- 隐藏加工细节，简化加工间的关系。
- 适当取名，避免空洞的名字。
- 表现的是数据流而不是控制流。
- 每个加工必须既有输入数据流，又有输出数据流，保持数据守恒。

### 1.5.3 决策树

- 决策树适用于描述存在多个分支判断的系统。
- 决策树每个内部节点表示一个属性上的测试，每个分支代表一个测试输出，每个叶节点代表一种类别。
- 通过构成决策树来求取净现值的期望值大于等于零的概率，评价项目风险，判断其可行性的决策分析方法，是直观运用概率分析的一种图解法。

### 1.5.4 用例图

- 用例图是编写需求说明时经常用到的需求表达方式，用于向开发、测试同事说明需求中用户与系统功能单元之间的关系。
- 用例图包括参与者，用例，关系三个要素。
- 参与者：不是特指人，是指系统以外的，在使用系统或与系统交互中所扮演的角色。因此参与者可以是人，可以是事物，也可以是时间或其他系统等等。
- 用例：是对包括变量在内的一组动作序列的描述，系统执行这些动作，并产生传递特定参与者的价值的可观察结果。
- 关系：参与者与用例之间的关系主要包括关联、归纳（泛化）、包含、拓展和依赖。

### 1.5.5 实体联系图（E-R图）

- 实体联系图是一种提供了实体，属性和联系的方法，用来描述现实世界的概念模型，表示在信息系统中概念模型的数据存储。
- 实体联系图常用于系统设计中的数据建模，用来表示实体与实体间的联系，不表现软件模块的执行过程。

### 1.5.6 N-S 盒图

- 描写软件模块执行过程的一类图。
- 具备展示顺序结构，选择结构和循环结构的能力。

### 1.5.7 PAD 图

- 问题分析图。
- 描写软件模块执行过程的一类图，一种表示程序控制流的结构图。
- 具备展示顺序结构，选择结构和循环结构的能力。

# 2.面向对象开发方法

- 面向对象开发方法分为面向对象的分析（OOA），面向对象的设计（OOD）和面向对象的程序设计（OOP）。
- OOA 是利用抽象构造问题的对象模型。
- OOD 是设计对象和对象之间的关系，如层次和集成；对象之间的通信方式，例如消息。
- OOP 指对系统功能的编码。

## 2.1 面向对象的分析

- 面向对象分析一般在软件需求工程中完成，主要形成以下三种类：
  - 边界类：对外部系统环境和内部交互进行建模
  - 控制类：对控制行为进行建模，多用来实现业务逻辑
  - 实体类：存储信息和对相关行为进行建模
- 面向对象分析使用 UML 类图进行结果展示

### 2.1.1 UML 的定义

- 统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。
- UML 是面向对象设计的建模工具，独立于任何具体程序设计语言。

### 2.1.2 UML 的分类

- **结构图**（静态建模）包括类图，组合结构体，构件图，部署图和对象图
- **行为图**（动态建模）包括活动图，顺序图，通信图，交互概况图，时序图，用例图与状态图。

### 2.1.3 UML 类图元素图示

- **一般类**在类图中用矩形框表示，矩形框分为三层：第一层是类名字；第二层是类的成员变量；第三层是类的方法。成员变量以及方法前的访问修饰符用符号来表示：`+` 表示 `public`；`-` 表示 `private`；`#` 表示 `protected`；不带符号表示 `default`。

![](/images/drawingbed/img/202307040938481.png)

- **抽象类**在UML类图中同样用矩形框表示，但是抽象类的类名以及抽象方法的名字都用斜体字表示。

![](/images/drawingbed/img/202307040938953.png)

- **接口**在类图中也是用矩形框表示，但是与类的表示法不同的是，接口在类图中的第一层顶端用构造型 `<<interface>>`表示，下面是接口的名字，第二层是方法。此外，接口还有另一种表示法，俗称棒棒糖表示法，就是类上面的一根棒棒糖（圆圈+实线）。圆圈旁为接口名称，接口方法在实现类中出现。

![](/images/drawingbed/img/202307040938512.png)

- **包**在类图中也是用矩形框表示，但包里面会包含类和接口。

![](/images/drawingbed/img/202307040939794.png)

### 2.1.4 UML 类图关系图示

- **实现关系**是指接口及其实现类之间的关系。在UML类图中，实现关系用空心三角和虚线组成的箭头来表示，从实现类指向接口。

![](/images/drawingbed/img/202307040939446.png)

- **泛化关系**（Generalization）是指对象与对象之间的继承关系。如果对象A和对象B之间存在继承关系，对象B是父对象，对象A是子对象。在UML类图中，泛化关系用空心三角和实线组成的箭头表示，从子类指向父类。

![](/images/drawingbed/img/202307040939988.png)

- **关联关系**（Association）是指对象和对象之间的连接，它使一个对象知道另一个对象的属性和方法。在代码中，关联关系表现为一个对象含有另一个对象的引用。也就是说，如果一个对象的类代码中，包含有另一个对象的引用，那么这两个对象之间就是关联关系。关联关系有单向关联和双向关联。如果两个对象都知道（即可以调用）对方的公共属性和操作，那么二者就是双向关联。如果只有一个对象知道（即可以调用）另一个对象的公共属性和操作，那么就是单向关联。大多数关联都是单向关联，单向关联关系更容易建立和维护，有助于寻找可重用的类。在UML图中，双向关联关系用带双箭头的实线或者无箭头的实线双线表示。单向关联用一个带箭头的实线表示，箭头指向被关联的对象。

![](/images/drawingbed/img/202307040939813.png)

- **依赖**（Dependency）关系是一种弱关联关系。如果对象A用到对象B，但是和B的关系不是太明显的时候，就可以把这种关系看作是依赖关系。。比如驾驶员和汽车的关系，驾驶员使用汽车，二者之间就是依赖关系。在UML类图中，依赖关系用一个带虚线的箭头表示，由使用方指向被使用方，表示使用方对象持有被使用方对象的引用。当使用方发生变化时，会影响被使用方的含义。

![](/images/drawingbed/img/202307040939906.png)

- **聚合**（Aggregation）是关联关系的一种特例，它体现的是整体与部分的拥有关系，即 has a 的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享，所以聚合关系也常称为共享关系。例如，公司部门与员工的关系，一个员工可以属于多个部门，一个部门撤消了，员工可以转到其它部门。在UML图中，聚合关系用空心菱形加实线箭头表示，空心菱形在整体一方，箭头指向部分一方。

![](/images/drawingbed/img/202307040940071.png)

- **组合**（Composition）也是关联关系的一种特例，它同样体现整体与部分间的包含关系，即 contains a 的关系。但此时整体与部分是不可分的，部分也不能给其它整体共享，作为整体的对象负责部分的对象的生命周期。这种关系比聚合更强，也称为强聚合。如果`A`组合`B`，则`A`需要知道`B`的生存周期，即可能`A`负责生成或者释放`B`，或者`A`通过某种途径知道`B`的生成和释放。例如，人包含头、躯干、四肢，它们的生命周期一致。当人出生时，头、躯干、四肢同时诞生。当人死亡时，作为人体组成部分的头、躯干、四肢同时死亡。在UML图中，组合关系用实心菱形加实线箭头表示，实心菱形在整体一方，箭头指向部分一方。

![](/images/drawingbed/img/202307040940827.png)

### 2.1.5 UML 类图的基本关系

- **实现**：类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约。
- **依赖**：两个事物间的语义关系，其中一个事物发生变化会影响另一个事物的语义。
- **继承**：一种特殊/一般关系，特殊元素对象可替代一般元素对象。
- **关联**：一种结构关系，描述一组链，链是对象间的联系。
- **聚合**：一种特殊的类型关联，是整体和部分的拥有关系。
- **组合**：一种特殊的类型关联，是整体和部分的包含关系。

### 2.1.6 UML 类图的应用场景

- 对系统的词汇建模。
- 对简单的协作建模。
- 对逻辑数据库模式建模。

## 2.2 面向对象设计

- 面向对象设计是面向对象方法在软件设计阶段应用与扩展的结果。
- 面向对象设计要求将面向对象分析所创建的分析模型转换为设计模型，解决如何作的问题。
- 面向对象设计的原则包括：
  - 开闭原则：软件实体应该对扩展开放，对修改关闭，即尽量在不修改原有代码的情况扩展实体的功能。
  - 里氏替换原则：如果使用基类对象满足要求，那么使用子类一定也可以。
  - 依赖导致原则：抽象不应该依赖于细节，细节应该依赖于抽象，对接口编程，而不是对实现编程，当程序代码在中传递参数时，或者在使用组合或者聚合关系是，尽量使用层次更高的抽象。
  - 组合/聚合复用原则：尽量使用组合和聚合的关系来使用一些原有的对象，使之成为新对象的一部分。
  - 接口隔离原则：使用多个专门的接口，而不是单一的总接口。
  - 最少知识原则（迪米特法则）：软件尽可能的减少和其他实体的相互作用。
- 几种典型的面向对象的开发方法：Coda 方法，Booch 方法和 OMT 方法。

# 3.瀑布模型

## 3.1 瀑布模型的内容

- 瀑布模型是将软件生存周期的各项活动规定为按固定顺序而连接的若干阶段工作，形如瀑布流水，最终得到软件产品。
- 瀑布模型核心思想是按工序将问题化简，将功能的实现与设计分开，便于分工协作，即采用结构化的分析与设计方法将逻辑实现与物理实现分开。
- 瀑布模型将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。

## 3.2 瀑布模型的优点

- 为项目提供了按阶段划分的检查点。
- 当前一阶段完成后，您只需要去关注后续阶段。
- 每一个阶段提交的所有制品都需要进行评审和验证
- 可在迭代模型中应用瀑布模型。增量迭代应用于瀑布模型。每次迭代产生一个可运行的版本,同时增加更多的功能。每次迭代必须经过质量和集成测试。
- 它提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导。

## 3.3 瀑布模型的缺点

- 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量。
- 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险。
- 通过过多的强制完成日期和里程碑来跟踪各个项目阶段。
- 瀑布模型的突出缺点是不适应用户需求的变化。

# 4.原型模型

## 4.1 原型模型的内容

- 原型法又称快速原型法，其基本的思想是在限定的时间内，用最经济的方法开发出一个可实际运行的系统模型，用户在运行使用整个原型的基础上，通过对其评价，提出改进意见，对原型进行修改，统一使用，评价过程反复进行，使原型逐步完善，直到完全满足用户的需求为止。
- 抛弃型原型，此类原型在系统真正实现后就会进行抛弃，不再使用。
- 进化型原型，此类原型的构造从目标系统的一个或多个基本需求出发，通过修改和追加的过程逐渐丰富，演化成为最终的系统。

## 4.2 原型模型的优点

- 构造方便、快速、造价低。
- 增加了用户与开发人员的交流。
- 用户在项目开发中占主导作用。
- 满足了用户的动态需求。
- 降低开发风险。

## 4.3 原型模型的缺点

- 因为用户的参与，使得忽视原型对实际环境的适应性等技术问题。
- 不适合大型、复杂项目开发。
- 对于技术层面远大于其分析层面的问题不宜使用原型法。

# 5.基于构件的模型

- 基于构件开发模型，是指采用预先打包的软件构件开发应用系统。其虽然具有许多螺旋模型的特点，它本质上是演化模型，需要以迭代方式构建软件。
- 构件的选择可以是组织内部开发的构件，也可以是商品化成品软件构件。
- 模型的优点在于软件复用，减少开发费用，缩短开发周期，提高软件的可靠性和生产率。
- 模型的缺点在于需要需求妥协，不完全符合用户需求。

# 6.快速应用开发

- 快速应用开发（Rapid Application Development，RAD）是一种比传统生命周期法（瀑布模型）快得多的开发方法，它强调使用极短的开发周期。
- RAD 模型是瀑布模型的高速变种，通过使用构件，复用已有的程序结构来获得快速的开发进度。
- RAD 模型的基本思想是让用户更主动地参与到系统分析、设计和构造活动中，通过迭代的构造方法，加速需求分析和设计，让用户提前看到一个可工作的系统。
- RAD 模型的开发阶段包括业务建模（数据流图）、数据建模（E-R 图）、过程建模（细化数据流图加工）、应用生成（编码）、测试与交付。
- 优点在于更好的质量，更好的风险控制，以及能在预算范围内能按时完成更多项目。
- 缺点在于对应用的模块化要求比较高，对需求分析要求严格，不适合技术风险高的项目。

# 7.敏捷模型

- 敏捷是以用户需求进化为核心，采用迭代、循序渐进的方式进行软件开发。
- 敏捷的目的是为了降低需求变化所带来的成本，其最大特点是响应变化。项目会被切分成多个子项目，每个子项目周期内的活动称为迭代。每次迭代都会发布一个运行的软件，并且在整个迭代过程中，软件一直处于可用状态。
- 敏捷更加关注人与人之间的沟通与交流，以人为核心，建立起全员参与的软件开发团队，使得团队互通有无。
- 敏捷要求个体和互动 高于 过程和工具。工作的软件 高于 详尽的文档。客户合作 高于 合同谈判。响应变化 高于 遵循计划。
- 敏捷模型的流派包括：
  - **极限编程（XP）**：一种近螺旋式的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期，通过积极的交流、反馈以及其他一系列的方法解决潜在的困难，并根据实际情况及时地调整开发过程。 XP 是激发开发人员创造性、使得管理负担最小的一组技术。
  - **水晶法**：认为每一个不同的项目都需要一套不同的策略、约定和方法论。
  - **并列争球法**：使用迭代的方法，其中把每30天一次的迭代成为一个冲刺，并按需求的优先级来实现产品。多个自组织和自治小组并行地递增实现产品，协调是通过简短的日常情况会议进行。
  - **自适应软件开发（ASD）**：有一个使命作为指导，它设立了项目的目标，但并不描述如何达到这个目标。

![](/images/drawingbed/img/202309191133399.png)

# 8.其他软件过程模型

- **瀑布模型**：又称为经典生命周期模型。是一种线性过程流模型，一个阶段活动完成后再开始下一个阶段活动。
- **V 模型**：瀑布模型的一个变体，强调在各个阶段进行测试和验证，将软件测试阶段与系统开发阶段对应起来，以提升软件质量。但 V 模型没有从根本上解决瀑布模型的问题，测试开始依然在程序编码阶段后。
- **原型模型**：通过构造原型，即一个软件系统的最初版本，用于验证概念、适用设计选型、发现更多的问题和可能的解决方法。原型是为定义需求服务的，在需求明确后，原型需要丢弃（至少部分丢弃）。
- **增量模型**：先开发出一个初始的实现，给用户使用并听取用户的使用意见，通过不断修改直到产生一个充分的版本。各活动不是分离而是交织在一起的。反应了我们解决问题的方法，我们很少能提前制定出完整的问题解决方案，而是摸着石头过河，逐步逼近结果。
- **螺旋模型**：一种风险驱动型的过程模型，每一阶段都有风险分析。吸收了瀑布模型和原型模型（演化模型）的优点。采用循环的方式逐步加深系统定义和实现的深度，同时降低风险。将过程（项目阶段）用螺旋线表示，每个螺旋线构成一个回路，每个回路由不同的风险驱动，根据这些风险，在每个阶段规划可选的策略方案。
- **喷泉模型**：一种以用户需求为动力，以对象为驱动的模型，主要用于描述面向对象的软件开发过程。喷泉模型的分析、设计、实现阶段可以重叠进行，开发人员可以边做分析边做实现，但由于阶段区分界限不是很明确，采用喷泉模型开发对文档要求比较严格。
- **RUP 统一过程模型**：一种用例驱动，以体系结构为核心，迭代及增量的软件过程框架，由 UML 方法和工具支持。
  - RUP 融合统一了瀑布、增量、演化、构件、面向对象五种基本软件过程。
  - RUP 将软件开发分为四个阶段：初始（确定项目的范围）、细化（对系统进行分析）、构建（实施）、交付（让用户进行必要的测试、对用户进行培训）。
  - RUP 每个阶段都会产生相应文档。初始阶段产生项目计划，精化阶段产生架构原型，构建阶段产生集成的软件产品，交付阶段产生最终的发布版本。
  - RUP 使用工件，活动，角色，工作流来描述开发过程。
- **敏捷模型**：软件项目在构建初期被拆分为多个相互联系而又独立运行的子项目，然后迭代完成各个子项目，开发过程中，各个子项目都要经过开发测试。

# 9.软件体系风格

![](/images/drawingbed/img/202309191156414.png)