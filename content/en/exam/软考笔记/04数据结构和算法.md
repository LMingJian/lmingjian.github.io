---
title: 04数据结构和算法
date: 2023-04-12
author: LM
---

## 线性表

线性表（List）是零个或多个数据元素的有限序列。除第一个元素外，每一个元素有且只有一个直接前驱元素，除了最后一个元素外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。线性表可以被实现为顺序存储（顺序表）或链式存储（链表）。线性表是一种逻辑结构，而顺序表和链表是线性表的物理表现。

## 顺序表

- 概念：用一组地址连续的存储单元依次存储线性表的数据元素，这种存储结构的线性表称为顺序表，也可以称为数组。

- 特点：逻辑上相邻的数据元素，物理次序也是相邻的。

- 只要确定好了存储线性表的起始位置，线性表中任一数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的储存结构，因为高级语言中的数组类型也是有随机存取的特性，所以通常我们都使用数组来描述数据结构中的顺序储存结构，用动态分配的一维数组表示线性表。
- 线性表的顺序存储结果在读、存数据是的时间复杂度是O(1)，插入、删除操作的时间复杂度是O(n)。
- 顺序表的优点：无须为表中元素之间的逻辑关系而增加额外的存储空间；可以快速的存取表中任一位置的元素。
- 顺序表的缺点：插入和删除操作需要移动大量元素；当线性表长度较大时，难以确定存储空间的容量；造成存储空间的“碎片”。

## 链表

- 概念：在存储数据元素时，额外开辟出一份内存空间去作指针，它总是指向下一个数据结点，一个个结点通过NEXT指针相互串联，通过访问NEXT，可以引导我们去访问链表的下一个结点。
- 特点：逻辑上相邻的数据元素，物理存储位置不一定相邻，它使用指针实现元素之间的逻辑关系。
- 链表的优点：相比起数组，链表解决了数组不方便移动，插入，删除元素的弊端，但相应的，链表付出了更加大的内存牺牲换来的这些功能的实现。

## 单链表，双链表，循环单链表的结构

![](/images/drawingbed/img/202306281946919.png)

- **单链表**：A -> B -> C
- **双链表**：A -> B -> C，也可以 C -> B -> A
- **循环链表**：A -> B -> C -> A，优点是可以从任意结点开始遍历整个链表

## 栈(Stack)

栈是运算受限的线性表，其限制是仅允许在一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。采用该结构的集合，对元素的存取有如下的特点：先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素），栈的入口和出口的都是栈的顶端位置。

![](/images/drawingbed/img/202306281948625.png)

## 堆(Heap)

堆是一种数据结构，分为大顶堆和小顶堆两种类型。

- 堆结构常用完全二叉树来进行表示
- 大顶堆要求父元素大于等于其左右孩子元素。
- 小顶堆要求父元素小于等于其左右孩子元素。

## 树与二叉树

树是n个结点的有限集合（n>=0），n为0时为空树。树中有一个根结点，它没有直接前驱，有零个或多个直接后继，根结点之外的n-1个结点可以划分成m个互不相交的有限集，这些有限集称为根的子树（子树互不相交）。

![](/images/drawingbed/img/202306281949219.png)

二叉树是有限的结点的集合，由根结点和不相交的二叉子树组成。满足以下条件的树形结构才能叫做二叉树：每个结点至多只有两棵子树且二叉树的子树有左右之分，其次序不能颠倒。

![](/images/drawingbed/img/202306281949550.png)

## 树的高度

- 对于整棵树而言，树的深度=树的高度，即树中所有结点层次的最大值，从上往下数
- 结点的高度不同于树的高度和深度，结点的高度指指从该结点到叶子结点的最长简单路径的边的条数，从下往上数（不同教材对结点的高度定义不同，有的从叶结点开始从1计数，有的从叶结点开始从0计数）

## 满二叉树与完全二叉树

- 满二叉树：每层结点均满，每层均具有最大结点数，又称完美二叉树，结点数量为 2^n - 1，n 为层数
- 完全二叉树：与满二叉树的编号对应，但不要求每层均具有最大结点数，结点数量最少为 2^(n-1)，第 n 层结点数量最多为 2^(n-1)

区别于联系：满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树

## 二叉树的遍历

按某种搜索路径，使二叉树每个结点均被访问且仅被访问一次。二叉树的遍历按其构成以及访问结点的顺序分为四种方式，即先序遍历、中序遍历、后序遍历、层次遍历。用L、D、R分别表示遍历左子树、访问根结点、遍历右子树。则有：

- 先序遍历：DLR（根左右）
- 中序遍历：LDR（左根右）
- 后序遍历：LRD（左右根）
- 层序遍历：按层次进行遍历，大部分情况下，一个序列会使用层序遍历组成二叉树，如 94，31，53，23，16，27

## 树的存储

- 双亲表示法：双亲表示法采用顺序表（也就是数组）存储普通树，其实现的核心思想是：顺序存储各个节点的同时，给各节点附加一个记录其父节点位置的变量。注意，根节点没有父节点（父节点又称为双亲节点），因此根节点记录父节点位置的变量通常置为 -1。

  ![](/images/drawingbed/img/202306281950111.png)

- 孩子表示法：孩子表示法存储普通树采用的是 "顺序表+链表" 的组合结构，其存储过程是：从树的根节点开始，使用顺序表依次存储树中各个节点。需要注意，与双亲表示法不同的是，孩子表示法会给各个节点配备一个链表，用于存储各节点的孩子节点位于顺序表中的位置。如果节点没有孩子节点（叶子节点），则该节点的链表为空链表。

  ![](/images/drawingbed/img/202306281950946.png)

- 孩子-兄弟表示法：在树结构中，同一层的节点互为兄弟节点。所谓孩子兄弟表示法，指的是用将整棵树用二叉链表存储起来，具体实现方案是：从树的根节点开始，依次存储各个结点的孩子结点和兄弟结点。在二叉链表中，各个结点包含三部分内容：节点的值；指向孩子结点的指针；指向兄弟结点的指针；

  ![](/images/drawingbed/img/202306281950187.png)

## 排序

![](/images/drawingbed/img/202306281951207.png)

## 快速排序

快速排序的基本思想是，通过一轮的排序将序列分割成独立的两部分，其中一部分序列的关键字（这里主要用值来表示）均比另一部分关键字小。继续对长度较短的序列进行同样的分割，最后到达整体有序。在排序过程中，由于已经分开的两部分的元素不需要进行比较，故减少了比较次数，降低了排序时间。

## 时间复杂度

时间复杂度是估算出的程序运行时间，通常会用算法的操作单元数量来代表程序消耗的时间。

【 大O符号表示法】

在大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：**算法的渐进时间复杂度**。

```
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

在上面的例子，假设每行代码的执行时间都是一样的，我们用 1 颗粒时间来表示，那么这个例子的第一行会执行 n+1 次，耗时是 n+1 个颗粒时间，第三行的执行时间是 n 个颗粒时间，第四行的执行时间也是 n 个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 n+1 颗粒时间 + n 颗粒时间 + n 颗粒时间 ，即 (1+3n) 个颗粒时间，即： T(n) = (1+3n) X 颗粒时间，从这个结果可以看出，这个算法的耗时是随着 n 的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)

为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。所以上面的例子中，如果 n 无限大的时候，T(n) = time(1+3n) 中的常量1就没有意义了，倍数3也意义不大。因此直接简化为 T(n) = O(n) 就可以了。

常见的时间复杂度量级有：

- 常数阶 O(1)：无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，表示它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

- 线性阶 O(n)：如下面循环里面的代码，每循环 n 次代码就会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化。

  ```text
  for(i=1; i<=n; ++i){
     j = i;
     j++;
  }
  ```

- 对数阶 O(logN)：如下面循环里面的代码，由于每次循环都将 i 乘以 2，1 次是 2^1，2 次是 2^2，x 次就是 2^x，所以循环 x 次之后，i 就大于 n，循环退出，也就是说循环最多（2^x = N）执行 $log_2N$ 次。因此这种情况下，时间复杂度为 O(logN)，省略底数。

  ```text
  int i = 1;
  while(i<n){
      i = i * 2;
  }
  ```

- 线性对数阶 O(nlogN)：将时间复杂度为 O(logN) 的代码循环 n 遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了 O(nlogN)。

  ```text
  for(m=1; m<n; m++){
      i = 1;
      while(i<n){
          i = i * 2;
      }
  }
  ```

- 平方阶 O(n²)：如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。

  ```
  for(x=1; i<=n; x++){
     for(i=1; i<=n; i++){
         j = i;
         j++;
      }
  }
  ```

- 立方阶 O(n³)，K次方阶 O(n^k)：与平方阶相似，循环多少次，多少阶。

上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。

## 空间复杂度

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势。

空间复杂度比较常用的有：

- O(1)：如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)

- O(n)：如下面代码中，第一行 new 了一个数组出来，这个数据占用的大小为 n，在执行循环时，没有再分配新的空间，因此这段代码的空间复杂度为 O(n)

  ```text
  int[] m = new int[n]
  for(i=1; i<=n; ++i){
     j = i;
     j++;
  }
  ```

## 哈希表

哈希表是一种搜索结构，当数据量大时，哈希搜索的效率高，平均时间复杂度O(1)。

【哈希查找】：

- （1）在插入时，根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放。
- （2）在搜索时，对元素的关键码进行同样的计算，把求得的函数值当作元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功。

【哈希冲突】：

- 对于两个数据元素的关键字 Ki 和 Kj（i != j），有 Ki != Kj ( i != j) ，但 HashFun( Ki ) ==HashFun( Kj ) ，将该种现象称为哈希冲突或哈希碰撞。

【常见的求哈希值方法】

- 直接定址法：：取关键字的某个线性函数为散列地址：Hash（Key）= A X Key + B。适合查找比较小且连续的情况

- 除留余数法：设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数，按照哈希函数：Hash( key ) = key % p ( p <= m) ，将关键码转换成哈希地址。

- 平方取中法
- 折叠法
- 随机数法
- 数学分析法

【**线性探查法**解决冲突】

给出一组元素，它们的关键码为：37，25，14，36，49，68，57，11，散列表为 HT[12]，表的大小 m=12 ，11 是最接近 m 的质数，因此 Hash（key）= key % 11，得出哈希值。在添加元素时，使用散列函数值确定元素的插入位置，如果此空间有值，产生冲突，则依次查看其后的下一个桶，直到发现空位置插入新元素。

![](/images/drawingbed/img/202306281951497.png)

## 矩阵

由 m × n 个数 aij 排成的 m 行 n 列的数表称为 m 行 n 列的矩阵，简称 m × n 矩阵。元素是实数的矩阵称为实矩阵，元素是复数的矩阵称为复矩阵。而行数与列数都等于 n 的矩阵称为 n 阶矩阵或 n 阶方阵。

矩阵计算：加，减，数乘，转置

![](/images/drawingbed/img/202306281952070.png)

矩阵共轭，实部不变，虚部取负

![](/images/drawingbed/img/202306281953695.png)

## 有向图

有向图是一副具有方向性的图，是有一组顶点和一组有方向的边组成的，每条方向的边都连接着一对有序的顶点。PS：*全部由无向边构成的图称为无向图*

- 出度：有某个顶点指出的边的个数称为该顶点的出度。
- 入度：指向某个顶点的边的个数称为该顶点的入度。
- 度：入度与出度，称为该顶点的度。

![](/images/drawingbed/img/202306281953341.png)

如上图所示，顶点A的出度为2，入度为1，度为3

## 邻接矩阵

无向图的邻接矩阵，有连接的节点置 1，无连接的为 0

![](/images/drawingbed/img/202306281953018.png)

有向图的邻接矩阵，入度的节点置 1，无连接或出度的为 0

![](/images/drawingbed/img/202306281954074.png)

有权图的邻接矩阵，入度的节点置为权值，无连接或出度的为 ∞

![](/images/drawingbed/img/202306281954082.png)

## 邻接链表

使用邻接链表存储数据时，将存储节点与对应指向的节点，按顺序构成链表存储。如上述邻接矩阵中的有向表，存储时：

- V1 -> V2 -> V3（表结点 2）
- V2（表结点 0）
- V3 -> V4（表结点 1）
- V4 -> V1（表结点 1）

## 按行存储和按列存储

在一般情况下，存储单元是单一的存储结构，但因为二维数组是多维的结构，若使用单一的存储结构就会出现次序约定的问题，因此就有了以列序为主序（按列存储）和以行序为主序（按行存储）的存储方式。比如 m 行 n 列二维数组 Amn，按行存储次序为 a11,a12,…,a1n,a21,a22,…,a2n,……,am1,am2,…amn；按列存储次序为 a11,a21,…,am1,a12,a22,…,am2,……,a1n,a2n,…amn

- 按行存储：`LOC(i,j) = LOC(0,0) + (n*(i-1)+(j-1))*L`，LOC(i,j) 是 a(i,j) 的存储位置， LOC(0,0) 是 a(0,0) 的存储位置（即二维数组的起始存储位置，为称为基地址或基址），n 是数组的总列数，L 是单个数据元素占据的存储单元。
- 按列存储：`LOC(i,j) = LOC(0,0) + (m*(j-1)+(i-1))*L`，LOC(i,j) 是 a(i,j) 的存储位置， LOC(0,0) 是 a(0,0) 的存储位置（即二维数组的起始存储位置，为称为基地址或基址），m 是数组的总行数，L 是单个数据元素占据的存储单元。

此外，在矩阵运算中，选择合适的按行存储或按列存储有利于提高运算速度。比如在矩阵 A * B 时，由于矩阵相乘是以行 * 列进行的，因此，为了更快的找到数据，可以对 A 进行按行存储，对 B 进行按列存储。

