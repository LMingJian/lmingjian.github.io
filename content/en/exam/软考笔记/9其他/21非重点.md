---
title: 21非重点
date: 2023-05-24
author: LM
---

## 11.计算机的体系结构分类

- **单指令流单数据流 SISD**：同一时刻内，只有一个控制流，一个数据流，即只能单独执行一条指令，并处理一条数据。
- **多指令流单数据流 MISD**：具有多个处理单元，按多条指令的要求对同一个数据流进行处理。
- **单指令流多数据流 SIMD**：能以并行同步的方式在同一时间内执行同一条指令，同时可以处理多个数据。
- **多指令流多数据流 MIMD**：多个处理单元根据不同的控制流程处理不同的多个数据。

## 14.串联系统的故障率

- 串联系统的故障率等于串联的每个元件的故障率乘积。
- 平均故障间隔时间等于故障率乘积的倒数。

### 2.5 分布式数据库

- 分布式数据库系统通常使用较小的计算机系统，每台计算机可单独放在一个地方，每台计算机中都可能有DBMS（数据库管理系统）的一份完整拷贝副本，或者部分拷贝副本，并具有自己局部的数据库，位于不同地点的许多计算机通过网络互相连接，共同组成一个完整的、全局的逻辑上集中、物理上分布的大型数据库。
- 分布式数据库系统 （DDBS）包含分布式数据库管理系统（DDBMS）和分布式数据库（DDB)。在分布式数据库系统中，一个应用程序可以对数据库进行透明操作，数据库中的数据分别在不同的局部数据库中存储、由不同的DBMS进行管理、在不同的机器上运行、由不同的操作系统支持、被不同的通信网络连接在一起。

### 2.6 分布式数据库的透明特性

- **分片透明**：指用户不必了解数据是如何分片的，用户或应用程序不需要知道逻辑上访问的表是怎么分块存储的。分片透明性是最高层次的透明性，如果用户能在全局关系一级操作，则数据如何分布，如何存储等细节自不必关系，其应用程序的编写与集中式数据库相同。
- **复制透明**：采用复制技术的分布方法，用户不知道数据是复制到哪些节点，如何复制的。用户不用关心数据库在网络中各个节点的复制情况。
- **位置透明**：用户不必知道所操作的数据放在何处，即数据分配到哪个或哪些站点存储对用户是透明的。
- **逻辑透明**：局部映像透明性（逻辑透明）是最低层次的透明性，该透明性提供数据到局部数据库的映像，即用户或应用程序无需知道局部使用是哪种数据模型、使用哪种数据操纵语言。局部映像透明性对异构型和同构异质的分布式数据库系统非常重要。

### 2.10 数据库规范化

- 利用规范化理论，使关系模式的函数依赖集满足特定的要求，满足特定要求的关系模式叫做范式。
- 关系按此规范化程度从低到高可分为 5 级范式，分别称为 1NF、2NF、3NF ( BCNF）、 4NF、5NF。
- 规范化程度较高者必是较低者的子集，即 5NF ⊆ 4NF⊆BCNF⊆3NF⊆2NF⊆1NF，一个低一级范式的关系模式，通过模式分解可以转换成若干个高一级范式的关系模式的集合，这个过程称作规范化。
- **1NF**：消除组中的重复，也就是说列中是否存储了其他列中的信息（**每个字段不可再分**）
- **2NF**：消除部分依赖列，也就是说是否有依赖于一部分主键的列（**不存在部分依赖，非主键字段完全依赖主键字段**）
- **3NF**：消除非依赖列，不存在依赖于非主键的列（**不存在传递依赖**）
- **BCNF**：消除部分和依赖列（**不存在部分和依赖传递**）
- **4NF**：消除非平凡且非函数依赖的多值依赖（**在全键表中，键的一部分能确定至多其他一个字段的多个值**）（存在多值属性的情况时，应该将该实体的码和相关的多值属性独立构成一个关系模式）
- **5NF**：消除不是由候选码所蕴含的连接依赖

### 4.函数依赖

1. **完全函数依赖**：在关系中，如果 X -> Y，对与 X 的任意一个真子集 X'，都不存在 X' -> Y，则称 Y 对 X 完全依赖。例如，在成绩表（学号，课程，成绩）关系中，有函数依赖：（学号，课程）-> 成绩，但学号不决定成绩，课程不决定成绩，所以（学号，课程）->成绩 是完全函数依赖
2. **平凡函数依赖**：在关系中，如果 X ->Y，但 X 包含 Y，则称 X→Y 是平凡的函数依赖。如：关系R(Sno, Cno)，依赖关系(Sno, Cno)→Sno，(Sno, Cno)→Cno都是平凡函数依赖。
3. **非平凡函数依赖**：在关系中，如果 X→Y，但 X 不包含 Y，则称 X→Y 是非平凡的函数依赖。如：关系R(Sno, Cno, Grade)，依赖关系(Sno, Cno)→Grade是非平凡函数依赖。
4. **部分函数依赖**：在关系中，如果 X -> Y，但 Y 不完全依赖于 X，存在 X 的子集使得 X1 -> Y，则称 Y 对 X 部分函数依赖。
5. **传递函数依赖**：在关系中，当且仅当 X->Y，Y->Z 时，称 Z 对 X 传递函数依赖。例如，S# -> SB，SB -> TN，即 TN 传递函数依赖于 S#

## 1.色泽三要素

- **色相**：色彩的学名。 比如红橙黄绿青蓝紫是色相，而譬如加入情感的哪些色彩命名，比如水晶粉、芥末色，都不能叫色相。
- **明度**：也称饱和度，色彩的明暗程度，以高低判断，最高明度是白色，最低明度是黑色。
- **纯度**：色彩的鲜艳程度，类比的理解就是咸度或者酒精度，某个色彩含某个颜色越多，其纯度也就越高。

## 2.色彩深度（图像深度）

- 在计算机图形学领域中表示在位图或者视频帧缓冲区中储存1像素的颜色所用的位数，它也称为位/像素（bpp）。色彩深度越高，可用的颜色就越多。色彩深度使用 n 位颜色说明。若色彩深度是 n 位，即有 2^n 种颜色选择，而储存每像素所用的位数就是 n。常见的有：8位、16位、32位

### 11.3 IIS 下多站点的配置

- **采用虚拟主机时**，发布的站点可以存在多个独立域名。
- **采用虚拟目录时**，发布的站点没有独立的域名，而是在主域名下建立虚拟目录。

## 1.项目估算

### 1.1 项目估算的定义

- 项目估算是对需求分析、设计、编码、测试、集成交付等整个软件开发过程所花费工作量、时间、成本等的预测。
- 项目估算是制定合理的项目计划，更好的控制软件开发活动的基础。
- 软件项目估算涉及人、技术、环境等多种因素，因此很难在项目完成前准确地估算出开发软件所需的成本、持续时间、和工作量。通常使用多种估算方法结合来提高估算精度。

### 1.2 三点估算法

- 三点估算法，也叫 PERT (Program Evaluation and Review Technique) 估算法，即计划评估和审查技术。
- 在估算活动工期或活动成本时，考虑三种可能的情况（最好，最坏，一般）三种情况，得出最乐观工期、最悲观工期、最可能工期，再据此计算期望工期（平均工期）。

### 1.3 PERT 图的概念

- **事件**（Events）表示主要活动结束的一点；
- **活动**（Activities）表示从一个事件到另一个事件之间的过程；
- **松弛时间**（slack time）不影响完工前提下可能被推迟完成的最大时间。
  - 关键路径上的任务松弛时间为 0，松弛时间等于最晚开始时间减去最早开始时间，或关键路径的总时间减去包含该任务的最长路径花的时间；
  - 最早开始时间是在关键路径上，从开始到该任务的最早执行的时间（从开始到目标节点最长的路线）；
  - 最晚开始时间是关键路径的总时间减去反向得出该任务的时间（从最后一个节点倒过来向前做差，取最长的路径）；
- **关键路线**（Critical Path）是PERT网络中花费时间最长的事件和活动的序列。从开始到结束得所有路径中，所花时间最长的一条为关键路径。

### 1.4 PERT 图的计算

示例：某软件项目的活动图如下图所示，其中顶点表示项目里程碑，连接顶点的边表示包含的活动，边上的数字表示活动的持续时间(天)，则完成该项目的最少时间为( )天。活动 FG 的松驰时间为( )天（晚多少天开始）。

![](/images/drawingbed/img/202307041001185.png)

- 完成该项目的最少时间是指活动图中的关键路线耗费时间（保证活动图所有活动都可能完成，所以要最长的路线），即最长的耗费时间；
- 本题关键路径为ADFHJ（或ADFIHJ）共计37天，经过FG的最长路径为ADFGJ共计28天，所以松弛时间为37-28=9
- 本题活动FG最早开始时间18（关键路径ADF），最晚开始时间27（关键路径JGF），所以松弛时间为27-18=9

示例：某软件项目的活动图如下图所示，其中顶点表示项目里程碑，连接顶点的边表示包含的活动，边上的数字表示活动的持续时间（天）。活动  EH 最多可以晚开始（ ）天而不影响项目的进度。由于某种原因，现在需要同一个工作人员完成 BC 和 BD ，则完成该项目的最少时间为（ ）天。

![](/images/drawingbed/img/202307041001520.png)

- 总工期为18天，CE执行完为10天，倒推HJ在H点时为18-4=14.EH持续需要2天，则自由时间为14-2-10 = 2
- BC持续时间3天，BD持续时间2天，由一人完成，则可以把BC持续时间作为5天，BD持续时间也为5天，则关键路径为ABDGFJ（21天），ABCEFJ（20天）。因为 21 > 20 > 18（关键路径），所以综合来看ABCEFJ是20天是最少的路径，符合题干的“最少”要求。

示例：下图是一个软件项目的活动图，其中顶点表示项目里程碑，连接顶点的边表示包含的活动，则里程碑（  ）没有按时完成会影响整个项目的进度。若活动0+2完成后，停止3天才开始活动2+6，则完成整个项目的最少时间是（  ）天。

![](/images/drawingbed/img/202307041001929.png)

- 关键路径0→2→5→7→8→9。因此如果该路径上的一个里程碑没有完成，就会影响整个项目进度。
- 活动0+2完成后，停止3天才开始活动2+6，则会影响路径0→2→6→9，该路径的长度为53+3=56大于原来的关键路径，由于0→3→6→9路径需要等待里程碑6完成，所以该路径也将发生变化即由原来的50变为53天，仍然要小于0→2→6→9的56天，而其他路径则不受影响，所以关键路径变为0→2→6→9共计56天。                

## 2.软件项目管理

### 2.1 软件项目管理的定义

- 软件项目管理的对象是软件项目。
- 为了使软件项目开发获得成功，必须对软件开发项目的工作范围、可能遇到的风险、需要的资源、要实现的任务、经历的里程碑、花费的工作量（成本）以及进度的安排等做到心中有数。
- 软件项目管理的范围覆盖了整个软件工程过程，即开始于技术工作开始之前，在软件从概念到实现的过程中持续进行，最后终止于软件工程过程结束。

### 2.2 项目初始阶段的管理

- 软件开发项目管理的首要阶段需要确定项目的目标范围，理解要解决的问题，包括开发商和客户双方的协议合同、软件产品主要需要实现的功能和这些功能所量化的范围、项目开发的周期等方面。
- 项目组要系统地阐述项目的范围，确定所要实现的软件系统的资料、功能、性能、目标及预期达到的效果，提出问题及充分描述问题，并进行成本的粗略估计，通过技术评估、经济分析，论证项目在资源、时间、效果、资金、实施方法和技术等方面的可行性。

## 1.线性数据结构

### 1.1 线性表

- 线性表（List）是零个或多个数据元素的有限序列。除第一个元素外，每一个元素有且只有一个直接前驱元素，除了最后一个元素外，每一个元素有且只有一个直接后继元素，数据元素之间的关系是一对一的关系。
- 在线性表中，查找是运算速度最快的操作，因为插入和删除元素都需要修改前驱和后继的指针，而查找只要找到该位置读取即可。

### 1.2 顺序表

- 用一组地址连续的存储单元依次存储线性表的数据元素，这种存储结构的线性表称为顺序表，也可以称为数组。
- 其特点是逻辑上相邻的数据元素，物理次序也是相邻的。只要确定好了存储顺序表的起始位置，顺序表中任一数据元素都可以随机存取。
- 顺序表读、存数据的时间复杂度是 O(1)，插入、删除操作的时间复杂度是 O(n)。
- 顺序表的优点是无须为表中元素之间的逻辑关系而增加额外的存储空间，可以快速的存取表中任一位置的元素。
- 顺序表的缺点是插入和删除操作需要移动大量元素，且当线性表长度较大时，难以确定存储空间的容量，造成存储空间的碎片。

### 1.3 链表

- 在存储数据元素时，额外开辟出一份内存空间去作指针，它总是指向下一个数据结点，一个个结点通过 NEXT 指针相互串联，通过访问 NEXT，可以引导我们去访问链表的下一个结点。具有这样链式存储结构的线性表称为链表。
- 其特点是逻辑上相邻的数据元素，物理存储位置不一定相邻，它使用指针实现元素之间的逻辑关系。
- 链表的优点是相比起数组，链表解决了数组不方便移动，插入，删除元素的弊端，但相应的，链表付出了更加大的内存牺牲换来的这些功能的实现。

### 1.4 单链表，双链表，循环单链表的结构

- **单链表**：A -> B -> C
- **双链表**：A -> B -> C，也可以 C -> B -> A
- **循环链表**：A -> B -> C -> A，优点是可以从任意结点开始遍历整个链表。

![](/images/drawingbed/img/202306281946919.png)

### 1.5 栈(Stack)

- 栈是运算受限的线性表，其限制是仅允许在一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。
- 其特点是先进后出，栈的入口和出口的都是栈的顶端位置。

![](/images/drawingbed/img/202306281948625.png)

### 1.6 队列

- 队列是一种只允许在一端进行插入，而在另一端进行删除的线性表，是一种操作受限的线性表。在表中只允许进行插入的一端称为队尾，只允许进行删除的一端称为队头。
- 其特点是先进先出。

## 2.树形数据结构

### 2.1 树的定义

- 树是 n 个结点的有限集合（n>=0），n 为 0 时为空树。树中有一个根结点，它没有直接前驱，有零个或多个直接后继，根结点之外的 n-1 个结点可以划分成 m 个互不相交的有限集，这些有限集称为根的子树（子树互不相交）。

![](/images/drawingbed/img/202306281949219.png)

### 2.2 树的高度

- 对于整棵树而言，树的深度 = 树的高度，即从上往下数，树中所有结点层次的最大值。
- 结点的高度不同于树的高度和深度，结点的高度指从该结点到叶子结点的最长简单路径的边的条数，从下往上数。
- 在计算时，把树类比为带地下室的高楼，负一层、负二层，那么要计算其结点或根高度和深度，可以将根结点看作楼顶，与该结点之间距离最远的叶子结点为楼底，计算目标节点所在楼层。

### 2.3 二叉树的定义

- 二叉树是有限的结点的集合，由根结点和不相交的二叉子树组成，每个结点至多只有两棵子树且二叉树的子树有左右之分，次序不能颠倒。

![](/images/drawingbed/img/202306281949550.png)

### 2.4 满二叉树与完全二叉树

- **满二叉树**：每层结点均满，每层均具有最大结点数，又称完美二叉树，结点数量为 2^n - 1，n 为层数
- **完全二叉树**：与满二叉树的编号对应，但不要求每层均具有最大结点数，结点数量最少为 2^(n-1)，第 n 层结点数量最多为 2^(n-1)
- 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树

### 2.5 二叉树的遍历

- **先序遍历**：DLR（根左右，L、D、R 分别表示遍历左子树、访问根结点、遍历右子树）
- **中序遍历**：LDR（左根右）
- **后序遍历**：LRD（左右根）
- **层序遍历**：按层次进行遍历，大部分情况下，一个序列会使用层序遍历组成二叉树，如 94，31，53，23，16，27

### 2.6 双亲表示法

- 双亲表示法采用顺序表（也就是数组）存储普通树，其实现的核心思想是：顺序存储各个节点的同时，给各节点附加一个记录其父节点位置的变量。注意，根节点没有父节点（父节点又称为双亲节点），因此根节点记录父节点位置的变量通常置为 -1。

![](/images/drawingbed/img/202306281950111.png)

### 2.7 孩子表示法

- 孩子表示法存储普通树采用的是 "顺序表+链表" 的组合结构，其存储过程是：从树的根节点开始，使用顺序表依次存储树中各个节点。需要注意，与双亲表示法不同的是，孩子表示法会给各个节点配备一个链表，用于存储各节点的孩子节点位于顺序表中的位置。如果节点没有孩子节点（叶子节点），则该节点的链表为空链表。

![](/images/drawingbed/img/202306281950946.png)

### 2.8 孩子-兄弟表示法

- 在树结构中，同一层的节点互为兄弟节点。所谓孩子兄弟表示法，指的是用将整棵树用二叉链表存储起来，具体实现方案是：从树的根节点开始，依次存储各个结点的孩子结点和兄弟结点。在二叉链表中，各个结点包含三部分内容：节点的值；指向孩子结点的指针；指向兄弟结点的指针；

![](/images/drawingbed/img/202306281950187.png)

### 2.9 堆(Heap)

- 堆是一种数据结构，常用完全二叉树来进行表示，分为大顶堆和小顶堆两种类型。
- **大顶堆**要求父元素大于等于其左右孩子元素。
- **小顶堆**要求父元素小于等于其左右孩子元素。

## 3.排序算法

![](/images/drawingbed/img/202306281951207.png)

**当序列有序时，使用插入排序的效率最高。**

## 4.时间复杂度

### 4.1 时间复杂度的概念

时间复杂度是估算出的程序运行时间，通常会用算法的操作单元数量来代表程序消耗的时间。

在大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：**算法的渐进时间复杂度**。

```
for(i=1; i<=n; ++i){
   j = i;
   j++;
}
```

在上面的例子，假设每行代码的执行时间都是一样的，我们用 1 颗粒时间来表示，那么这个例子的第一行会执行 n+1 次，耗时是 n+1 个颗粒时间，第三行的执行时间是 n 个颗粒时间，第四行的执行时间也是 n 个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 n+1 颗粒时间 + n 颗粒时间 + n 颗粒时间 ，即 (1+3n) 个颗粒时间，即： T(n) = (1+3n) X 颗粒时间，从这个结果可以看出，这个算法的耗时是随着 n 的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)。

为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。所以上面的例子中，如果 n 无限大的时候，T(n) = time(1+3n) 中的常量1就没有意义了，倍数3也意义不大。因此直接简化为 T(n) = O(n) 就可以了。

### 4.2 常数阶 O(1)

- 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，表示它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

### 4.3 线性阶 O(n)

- 如下面循环里面的代码，每循环 n 次代码就会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化。

```text
  for(i=1; i<=n; ++i){
     j = i;
     j++;
  }
```

### 4.4 对数阶 O(logN)

- 如下面循环里面的代码，由于每次循环都将 i 乘以 2，1 次是 2^1，2 次是 2^2，x 次就是 2^x，所以循环 x 次之后，i 就大于 n，循环退出，也就是说循环最多（2^x = N）执行 $log_2N$ 次。因此这种情况下，时间复杂度为 O(logN)，省略底数。

```text
  int i = 1;
  while(i<n){
      i = i * 2;
  }
```

### 4.5 线性对数阶 O(nlogN)

- 将时间复杂度为 O(logN) 的代码循环 n 遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了 O(nlogN)。

```text
  for(m=1; m<n; m++){
      i = 1;
      while(i<n){
          i = i * 2;
      }
  }
```

### 4.6 平方阶 O(n²)

- 如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。

```
  for(x=1; i<=n; x++){
     for(i=1; i<=n; i++){
         j = i;
         j++;
      }
  }
```

### 4.7 立方阶 O(n³)，K次方阶 O(n^k)

- 与平方阶相似，循环多少次，多少阶。
- 上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。

## 5.空间复杂度

### 5.1 空间复杂度的概念

- 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势。

### 5.2 O(1)

- 如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)。

### 5.3 O(n)

- 如下面代码中，第一行 new 了一个数组出来，这个数据占用的大小为 n，在执行循环时，没有再分配新的空间，因此这段代码的空间复杂度为 O(n)

```text
  int[] m = new int[n]
  for(i=1; i<=n; ++i){
     j = i;
     j++;
  }
```

## 6.哈希表

### 6.1 哈希表的定义

- 哈希表是一种搜索结构，当数据量大时，哈希搜索的效率高，平均时间复杂度O(1)。

### 6.2 哈希查找

- 在插入时，根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放。
- 在搜索时，对元素的关键码进行同样的计算，把求得的函数值当作元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功。

### 6.3 哈希冲突

- 对于两个数据元素的关键字 Ki 和 Kj(i != j)，有 Ki != Kj (i != j) ，但 HashFun( Ki ) ==HashFun( Kj ) ，将该种现象称为哈希冲突或哈希碰撞。

### 6.4 常见的求哈希值方法

- 直接定址法：：取关键字的某个线性函数为散列地址：Hash(Key)= A X Key + B。适合查找比较小且连续的情况
- 除留余数法：设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数，按照哈希函数：Hash( key ) = key % p ( p <= m ) ，将关键码转换成哈希地址。
- 平方取中法
- 折叠法
- 随机数法
- 数学分析法

### 6.5 使用线性探查法解决冲突

- 给出一组元素，它们的关键码为：37，25，14，36，49，68，57，11，散列表为 HT[12]，表的大小 m=12 ，11 是最接近 m 的质数，因此 Hash(key)= key % 11，得出哈希值。在添加元素时，使用散列函数值确定元素的插入位置，如果此空间有值，产生冲突，则依次查看其后的下一个桶，直到发现空位置插入新元素。

![](/images/drawingbed/img/202306281951497.png)

## 7.矩阵

### 7.1 矩阵的定义

- 由 m × n 个数 aij 排成的 m 行 n 列的数表称为 m 行 n 列的矩阵，简称 m × n 矩阵。元素是实数的矩阵称为实矩阵，元素是复数的矩阵称为复矩阵。而行数与列数都等于 n 的矩阵称为 n 阶矩阵或 n 阶方阵。

### 7.2 矩阵计算

- 加，减，数乘，转置

![](/images/drawingbed/img/202306281952070.png)

- 共轭，实部不变，虚部取负

![](/images/drawingbed/img/202306281953695.png)

### 7.3 按行存储和按列存储

- 在一般情况下，存储单元是单一的存储结构，但因为二维数组是多维的结构，若使用单一的存储结构就会出现次序约定的问题，因此就有了以列序为主序（按列存储）和以行序为主序（按行存储）的存储方式。
- 比如 m 行 n 列二维数组 Amn。
- 按行存储次序为 `a11,a12,…,a1n,a21,a22,…,a2n,……,am1,am2,…amn`。
- 按列存储次序为 `a11,a21,…,am1,a12,a22,…,am2,……,a1n,a2n,…amn`。

### 7.4 按行存储地址计算

- `LOC(i,j) = LOC(0,0) + (n*(i-1)+(j-1))*L`，`LOC(i,j)` 是 `a(i,j)` 的存储位置， `LOC(0,0)` 是 `a(0,0)` 的存储位置（即二维数组的起始存储位置，为称为基地址或基址），n 是数组的总列数，L 是单个数据元素占据的存储单元。

### 7.5 按列存储地址计算

- `LOC(i,j) = LOC(0,0) + (m*(j-1)+(i-1))*L`，`LOC(i,j)` 是 `a(i,j)` 的存储位置， `LOC(0,0)` 是 `a(0,0)` 的存储位置（即二维数组的起始存储位置，为称为基地址或基址），m 是数组的总行数，L 是单个数据元素占据的存储单元。

### 7.6 按行、列存储的优点

- 在矩阵运算中，选择合适的按行存储或按列存储有利于提高运算速度。比如在矩阵 A * B 时，由于矩阵相乘是以行 * 列进行的，因此，为了更快的找到数据，可以对 A 进行按行存储，对 B 进行按列存储。

## 8.有向图

### 8.1 有向图的概念

- 有向图是一副具有方向性的图，是有一组顶点和一组有方向的边组成的，每条方向的边都连接着一对有序的顶点。
- 全部由无向边构成的图称为无向图

### 8.2 有向图的度

- 出度：有某个顶点指出的边的个数称为该顶点的出度。
- 入度：指向某个顶点的边的个数称为该顶点的入度。
- 度：入度与出度，称为该顶点的度。
- 如下图所示，顶点 A 的出度为 2，入度为 1，度为 3

![](/images/drawingbed/img/202306281953341.png)

### 8.3 邻接矩阵

- 无向图的邻接矩阵，有连接的节点置 1，无连接的为 0

![](/images/drawingbed/img/202306281953018.png)

- 有向图的邻接矩阵，入度的节点置 1，无连接或出度的为 0

![](/images/drawingbed/img/202306281954074.png)

- 有权图的邻接矩阵，入度的节点置为权值，无连接或出度的为无限

![](/images/drawingbed/img/202306281954082.png)

### 8.4 邻接链表

- 使用邻接链表存储数据时，将存储节点与对应指向的节点，按顺序构成链表存储。
- V1 -> V2 -> V3（表结点 2）
- V2（表结点 0）
- V3 -> V4（表结点 1）
- V4 -> V1（表结点 1）

## 10.主流的程序设计语言

- **C**：对操作系统和系统实用程序，以及需要操作硬件的场合具有明显优势。具有很强的绘图能力和可移植性，以及数据处理能力。
- **C++**：一种静态数据类型检查且支持多重编程范式的通用程序设计语言。它支持过程程序设计，数据抽象，面向对象程序设计等多种程序设计风格。
- **C#**：微软发布的一种面向对象且运行于 .NET Framework 上的高级程序设计语言。其定义从 C 与 C++ 继承而来，但却具有与 Java 相似的语法和编译成中间代码再运行的过程。
- **Java**：Sun 发布的一种开放标准，包括 Java 虚拟机和 Java 接口。Java 将源程序编译成字节码，并通过 Java 虚拟机 JVM 来解释字节码运行，以此来实现跨平台。它具有简单，面向对象，分布式，解释性，可靠，安全，结构中立性，可移植性，高性能，多线程和动态性等优点。
- **SQL**：结构化查询语句，常使用于数据库管理系统的查询。
- **Visual Basic（VB）**：由微软开发的包含协助开发环境的事件驱动编程语言。程序员可以轻松地使用 VB 提供的组件快速建立一个应用程序。
- **XML**：扩展标记语言，一种简单的数据存储语言，其易于在任何应用程序中读取数据，不受平台限制。
- **HTML**：超文本标记语言，WWW 网络网页通用的描述语言。
- **JavaScript**：为适应动态网页制作的一种脚本语言，广泛用于网页制作。
- **Lua**：一个小巧易于被C/C++调用，或调用C/C++函数的脚本语言。为应用程序提供扩展和定制功能。
- **PHP**：超文本预处理语言，一种在服务器端执行的嵌入HTML文档的脚本语言，风格类似于C，能在放眼望去端完成 JavaScript，数据库查询等功能。
- **Python**：一种面向对象的解释性程序设计语言。
- **Ruby**：一种功能强大的面向对象脚本语言。

## 11.算法复杂度

### 11.1 时间复杂度

- 时间复杂度用以衡量算法执行的时间长短。
- 算法执行时间的度量不采用算法执行的绝对时间来计算，因为算法在不同机器上执行所花的时间不一样。所以在计算时，采用算法执行过程中其基本操作的执行次数（计算量）来度量。
- 记算法基本操作的重复执行次数是模块 n 的某个函数 $f(n)$ ，因此算法的时间复杂度记做 $T(n)=O(f(n))$。
- 在计算时间复杂度的时候，先找出算法的基本操作，并根据相应的语句确定其执行次数。然后再找出 $T(n)$ 的同数量级 $f(n)$ ，对 $T(n)/f(n)$ 求极限 c，c 即为时间复杂度 $O(f(n))$。例如：

```c
for(i=1;i<=n;i++){
    for(j=1;j<=n;j++){
        c[i][j]=0;  // 基本操作，执行了 n^2 次，两个循环，每个 n 次
        for(k=1;k<=n;k++){
            c[i][j]+=a[i][k]*b[k][j]  // 基本操作，执行了 n^3 次
        }
    }
}
```

- 因此 $T(n)=n^2+n^3$，因为 $n^3$ 为同数量级，对 $(n^2+n^3)/n^3$ 求极限有常数 c，得时间复杂度 $T(n)=O(n^3)$。

### 11.2 空间复杂度

- 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，使用 $O()$ 表示。
- 一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。
- 一个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小，它包括为参数表中形参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。若一个算法为 递归算法，其空间复杂度为递归所使用的堆栈空间的大小，它等于一次调用所分配的临时存储空间的大小乘以被调用的次数。
- 算法的空间复杂度一般以数量级的形式给出。如当一个算法的空间复杂度为一个常量，即不随被处理数据量 n 的大小而改变时，可表示为 O(1)；当一个算法的空间复杂度与以 2 为底的 n 的对数成正比时，可表示为 O(log2n)；当一个算法的空间复杂度与 n 成线性比例关系时，可表示为 O(n)；

### 8.7 极限编程的十二个最佳实践

1. 计划游戏（快速制定计划、随着细节的不断变化而完善）
2. 小型发布
3. 隐喻
4. 简单设计
5. 测试先行
6. 重构
7. 结对编程
8. 集体代码所有制
9. 持续集成
10. 每周工作40个小时
11. 现场客户
12. 编码标准 

## 9.软件体系风格

### 9.1 软件体系风格的定义

- 软件体系结构风格（Architectural Styles）是描述特定系统组织方式的惯用范例，强调了软件系统中通用的组织结构。
- 一个软件体系结构风格定义了构件和连接件类型的符号集，及规定了它们怎样组合起来的约束集合。

### 9.2 软件体系风格的类型

- **数据流风格**：批处理序列，管道/过滤器
- **调用/返回风格**：主程序/子程序，面向对象，层次结构
- **独立构建风格**：进程通讯，事件系统
- **虚拟机风格**：解释器，基于规则的系统
- **仓库风格**：数据库系统，超文本系统，黑版系统

### 9.3 主程序-子程序风格

- 主程序-子程序是结构化程序设计的一种典型的调用/返回风格，从功能的观点设计系统，通过逐步分解和细化，形成整个系统的体系结构。

### 9.4 面向对象风格

- 与前面的主程序-子程序风格比，虽然同是调用/返回风格的一种，但面向对象风格中的构件变成了对象，并且连接的方式也发生了相应的变化。
- 面向对象风格强调设计，全面的系统考虑，以及现实世界的对应关系。
- 对象对客户隐藏了实现的细节，实现了对内部表达的保护(封装数据/状态的完整)，可以在不影响客户的情况下改变对象的实现(低耦合，高重用，可维护)，方便系统的升级。
- 面向对象风格的缺点是对象交互时需要知道彼此的标识，多个对象对同一资源的访问(A和B同时需要使用C)可能对出现问题。

### 9.5 分层体系风格

- 分层体系风格是调用/返回风格的一种，它的组织为层次结构，每一层给外层提供服务，又作为它内层的客户。在某些系统中，内层只对相邻的层可见，组织间通过连接件（层间的协议）定义层次间的交互方式。
- 分层体系风格支持基于抽象程度逐渐递增的系统设计，支持层重用，支持功能增强，具有高扩展性，可维护性
- 分层体系风格的缺点是行为改变难以进行传递，上面的层过分依赖下面的层提供服务，相关数据传达时间长，数据传输低效，层次大小的难以清晰界定，并且缺少合适的、正确的层次抽象方法。

### 9.6 管道-过滤器风格

- 管道-过滤器风格是数据流风格的一种，它把系统任务分成若干连续的处理步骤，这些步骤由通过系统的数据流连接，一个步骤的输出是下一个步骤的输入。
- 管道-过滤器风格使得软构件具有良好的隐蔽性和高内聚、低耦合的特点，系统中已有的过滤器很容易用于新的待设计系统。
- 管道-过滤器风格允许设计者将整个系统的输入/输出行为看成是多个过滤器的行为的简单合成，支持软件重用，每个过滤器是作为一个单独的任务完成，支持与其它任务并行执行，任何两个过滤器都可被连接起来。因此，系统维护简单，容易进行扩展。
- 管道-过滤器风格由于过滤器是对输入的批量转换处理，对输入和输出有相应的说明限制，通常会导致进程成为批处理的结构。同时由于全局变量的共享很困难，因此通信交互性不强，当数据传输量很大而又有很多小的过滤器时代价较大，执行效率并不理想，交互性差，出现错误时如何做处理比较困难。

### 9.7 仓库风格

- 仓库体系风格是以数据为中心的体系结构，适合于数据由一个模块产生而由其他模块使用的情形。
- 仓库体系风格的优点是能在有限的范围内实验不同的问题解决者和诱导启发式的控制方法，容忍哪些不可靠的问题解决者，知识源可以重用，规模伸缩性好（方便添加新数据）。
- 仓库体系风格的缺点是测试困难，难以保障最佳解决方案，且控制策略通常需要启发诱导，计算开销大（工作量可能比较大，浪费多），数据修改困难，系统的复杂度高。

### 9.9 分布式架构

- 支持大量并发用户；容错和灾备能力；可灵活扩展的优点

## 10.设计模式

### 10.1 设计模式的定义

- 设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。
- 使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。
- 采用设计模式能复用相似问题的相同解决方案。

### 10.2 设计模式的三大类

- **创建型模式（Creational Pattern）**：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。包括：**（5种）单例模式、工厂模式、抽象工厂模式、建造者构建模式、原型模式**

- **结构型模式（Structural Pattern）**：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。包括：**（7种）适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式**

- **行为型模式（Behavioral Pattern）**：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。包括：**（11种）策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式**

### 10.3 设计模式的 UML 类图

[ 23种设计模式 UML 类图图解 ](https://blog.csdn.net/qq_40274514/article/details/124047443)

### 10.4 MVC 设计模式

- MVC 模型-视图-控制器是一种设计模式，它强制性地使应用程序的输入，处理和输出分开，使应用程序分为模型，视图，控制器 3 个模块，各自处理自己的任务。
- **视图是用户看到并与之交互的界面**，对于Web应用来说，可以概括为HTML界面，但有可能为XHTML、XML和Applet；主要负责呈现，也就是用户界面。
- **模型就是业务流程/状态的处理以及业务规则的制定**。业务模型的设计可以说是MVC最主要的核心；主要负责数据和业务逻辑。
- **控制器是接受用户输入并调用模型和视图完成用户需求**，控制器本身不输出任何内容并执行任何处理，只是接受请求并调用其他模式。
- MVC 的优点有：耦合性低；重用性高；部署快；生命周期成本低；可维护性高；
- MVC 的缺点有：运行效率低；调试困难；不适合小型，中等规模的应用程序；增加系统结构和实现的复杂性；视图与控制器间的过于紧密的连接并且降低了视图对模型数据的访问；
- **MVC常用的框架有：Struts、Spring、ZF、.NET MVC等。**


## 17.软件开发文档

- 软件开发文档可分为开发，管理和用户文档。
- 开发文档应当包括软件需求说明，可行性研究报告和项目开发计划。
- 文档是影响软件可维护性的决定因素。由于长期使用的大型软件系统在使用过程中必然会经受多次修改，所以文档比程序代码更重要。
- 软件文档应该描述如何使用这个系统，描述怎样安装和管理这个系统，描述系统需求和设计，描述系统的实现和测试，以便系统维护。

## 18.更多资料

[ 一文讲清十大软件过程模型 @知乎 ](https://zhuanlan.zhihu.com/p/379684828)

[ 软件工程——瀑布模型、快速原型模型、增量模型、螺旋模型、原型模型和增量模型的区别 @CSDN ](https://blog.csdn.net/zjuwxx/article/details/97252039)

[ 23种设计模式UML类图图解 @CSDN ](https://blog.csdn.net/qq_40274514/article/details/124047443)

[ 快速记忆23种设计模式 @知乎 ](https://zhuanlan.zhihu.com/p/128145128)

[ 一文讲清十大软件过程模型 @知乎 ](https://zhuanlan.zhihu.com/p/379684828)

## 4.测试用例

### 4.1 测试用例的定义

- 测试用例（Test Case）是为某个测试目标而编制的一组测试输入、执行步骤以及预期结果的集合，以便测试某个程序的路径或验证软件是否满足某个特定需求。

### 4.2 测试用例三要素

- 输入，预期输出，执行条件

### 4.3 测试用例的分类（按预期结果和作用）

- 通过（正面）测试用例：描述需求可以正确实现的测试用例
- 失败（负面）测试用例：描述需求可以不能实现的测试用例

### 4.4 测试用例的分类（按测试对象）

- 功能点测试用例：描述功能点使用的测试用例
- 业务流程用例：描述业务流程使用的测试用例

### 4.5 测试用例设计原则

- 测试用例的覆盖率不一定达到 100%
- 测试用例的数量不与覆盖率成正比，不能一味的追求覆盖率而增加测试用例，应当注意测试成本和覆盖率的选择
- 场景法适用于模拟复杂业务流程
- 等价类法适用于输入项少，输入项的属性或者特性相同的功能点
- 业务流程的测试需要提供多条数据来覆盖流程
- 经常使用边界值法验证界面输入值是否正确

## 8.软件测试文档

- **测试计划**：为了描述软件特性的测试而编写的文档计划，为了规范化测试内容，测试需要用到的资源等。
- **测试用例**：用于描述测试用例的具体细节工作，测试用例一般根据测试计划及测试策略来编写。
- **测试缺陷**：描述测试过程中相关缺陷信息，让团队成员更好的了解测试缺陷类型。
- **测试报告**：一份完整的描述测试结果的报告，对测试结果进行统计分析及总结。
- **测试需求文档，测试环境配置说明，缺陷报告，测试总结分析**。