---
title: 02操作系统基础知识
date: 2023-04-12
author: LM
---

## 1.操作系统

### 1.1 操作系统作用

- 管理计算机系统的全部软、硬件资源，对系统内各项资源板块开展调度工作，通过文件目录和目录项管理外存的数据，合理组织计算机的工作流程，以充分发挥计算机的算力，并为用户提供使用计算机的友好界面。

### 1.2 操作系统的特性

- 并发性
- 共享性
- 异步性

### 1.3 操作系统的位置

- 第一层：应用软件
- 第二层：其他系统软件，如数据库系统、编译软件、驱动程序
- **第三层：操作系统**
- 第四层：硬件

### 1.4 操作系统的类型

- **批处理操作系统**：通过将作业分组来进行工作，CPU 不会直接与作业进行交互，而是与根据作业间的相似之处创建的批处理任务进行交互。批处理操作系统通过将多个作业分组为较少的批处理任务来工作，使得系统对大量工作的管理变得容易，同时支持多个用户同时进行操控。 但是，批处理操作系统的成本很高，调试难度很大。示例：薪资系统，银行对帐单等。
- **分时操作系统**：操作系统为每个作业分配了一定的时间限制量子，完成一项工作后，再为另一项分配时间，保证每个作业在 CPU 中获得相等的时间。但是，分时操作系统通常都会有数据通信问题。例如： Unix，Multics 等。
- **网络操作系统**：操作系统在互连模型上工作，由客户端服务器(如小型专用网络)组成。与松散耦合的分布式系统不同，网络操作系统是紧密耦合的系统。这意味着连接到集中式服务器的所有计算机都知道彼此的信息，并且位于不同位置的不同系统都可以轻松访问地服务器，完成文件共享。 但是，网络操作系统的服务器组建，维护以及更新的成本非常高。例如：UNIX，Linux，Novell Netware，Microsoft Windows Server 2003 等。
- **分布式操作系统**：操作系统允许使用共享通信网络在全世界范围内互连各种系统。用户可以在网络上的任何地方共享文档，同时所有互连的系统都是独立的，一个系统的故障不会影响网络中的任何其他系统。分布式操作系统在所有操作系统中网络利用率最高。例如： LOCUS。
- **实时操作系统**：操作系统支持快速处理输入和对应关系，就像实时工作一样，不需要时间进行事务处理。
  - *硬实时*：在这些系统中，即使时间延迟很小也可能导致重大破坏。因此，响应时间不得超过安全时间。这些常用于导弹发射系统，自动降落伞系统等。
  - *软实时*：在这些系统中，时间限制并不严重，响应延迟可能不会导致破坏，但是，系统仍然会被认为是有故障的。这些常用于游戏的开发。

## 2.信号量机制（PV 操作）

### 2.1 信号量

- 信号量(Semaphore)，是在多进程环境下使用的一种设施，可以用来保证两个或多个关键代码段不被并发调用，实现进程同步和互斥的使用。
- 信号量 S 是一个整数，当大于等于 0 时，表示可供并发进程使用的资源数，当小于 0 时，表示正在等待使用临界区的进程数。对信号量可以施加 P 和 V 操作，P 请求资源，V 释放资源。执行 P 操作时，信号量 S 值减 1，执行 V 操作时，信号量 S 值加 1。

### 2.2 同步和互斥

- 在单CPU、多CPU以及分布式系统中，有多个进程并发甚至并行执行，对资源的共享和竞争使得并发进程之间相互制约，因为该原因通常产生意想不到的错误，且在程序逻辑上体现不出来。比如由于共享某些资源时，一个进程的执行可能影响其他进程的执行结果。为了避免上述问题的出现，操作系统中对进程的执行存在同步和互斥要求。
- **进程互斥**：两个或两个以上的进程不能同时进入关于同一组共享变量的临界区域，否则可能发送与时间相关的错误，这个现象称为进程互斥。进程互斥保证了临界资源在某一时刻不允许多个进程同时访问，只能单个进程访问。
- **进程同步**：在某些进程之间，会存在合作关系，例如某一个程序的输入、计算、打印三个程序段作为三个进程并发执行，由于这三个进程间存在着相互合作的关系，即先输入再计算、最后再打印的关系，所以这三个进程在并发执行时推进序列受到限制，要保证其合作关系正确，进程间这种关系称为同步关系。

### 2.3 同步信号量

- 初值一般设为 0，用来保证进程按一定顺序执行。低优先级的任务持有信号量，高优先级的任务需要这个信号量，只有当低优先级的任务释放信号量，高优先级的任务才能获取信号量。通过这种机制，低优先级的任务可以防止被高优先级的任务抢占。释放和获取分别在两个任务里完成。

### 2.4 互斥信号量

- 初值一般设为 1，用来保证一个资源同一时间只有一个进程访问。当一个任务想对资源访问时，为了防止别的任务也对该资源操作，它需要对该资源上锁，即获取一个互斥的信号量，以保证独享。释放和获取在一个任务里完成的。如果在某一程序段中，PV 操作成对出现，且针对同一信号量 S，则为互斥资源。

## 3.死锁机制

### 3.1 死锁

- 死锁，指两个或两个以上的进程在执行过程中因争夺资源而造成的一种相互等待的现象。若无外力作用，则该过程会一直进行下去。例如，进程 A 锁住了资源 1 等待的资源 2，而进程 B 锁住了资源 2 等待的资源 1，两个进程都在等待资源，而不能正常进行，即发生了死锁。

### 3.2 产生死锁的 4 个条件

- **互斥条件**：一个资源只能被一个进程使用。
- **请求和保持条件**：一个进程因请求资源阻塞时对以获得的资源保持不放。
- **不剥夺条件**：进程以获得的资源在未使用前不会被剥夺。
- **循环等待条件**：若干进程间形成一种头尾相接的循环等待资源关系。

## 4.操作系统的运行

### 4.1 进程

- 狭义定义：进程是操作系统中正在运行的程序的实例。
- 广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体。在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。

### 4.2 线程

- 线程是进程中的一个实体，是系统独立分配和调度的基本单位。多个线程共享进程中打开的文件，代码段和全局变量，但**线程不会共享线程内部的栈指针。**

### 4.3 三态模型

- 进程状态反映进程执行过程的变化，这些状态随着进程的执行和外界条件的变化而转换，在三态模型中，进程状态分为运行态，就绪态，阻塞态。
- **运行—>阻塞**：由于等待外设或主存等资源分配或人工干预引起的（**等待某件事**）
- **阻塞—>就绪**：等待条件已满足，只需分配到处理器后即可运行（ **等待某件事发生了**）
- **运行—>就绪**：不是由于自身原因，而是由外界使得运行态的进程让出处理器，此时变为就绪态（**时间片到**）
- **就绪—>运行**：资源释放后，系统按某种策略选择就绪队列中一个进程启动，变为运行态（ **进程调度** ）

![](/images/drawingbed/img/202306271938584.png)

### 4.4 进程资源图

- **P**：进程
- **R**：一类资源
- **R 中的圆圈数**：该类资源有几个
- **R→P（R 指向 P）**：分配一份 R 类资源给进程 P
- **P→R（P 指向 R）**：进程 P 申请一份 R 类资源

![](/images/drawingbed/img/202306271939763.png)

### 4.5 判断进程资源图是否阻塞。

- 当 R 中所有资源都分配出去了，而此时还有进程 P 向 R 申请资源，则申请资源 R 的进程 P 成为阻塞节点。
- R 中所有资源没有全部都分配出去了，而此时还有进程 P 向 R 申请资源，则申请资源 R 的进程 P 成为非阻塞节点。

### 4.6 判断进程资源图是否死锁。

- 如果所有节点都是阻塞的，此进程资源图不可以化简，可以说这个系统是死锁的。
- 如果有节点不是阻塞的，将非阻塞节点周围的箭头删去，只保留阻塞节点的箭头，此时，观察现在得到的图中，原来的阻塞节点是否阻塞？如果在新图中，它是非阻塞的，则原图是可以化简的，可以说这个系统是非死锁的。

### 4.7 设备利用率的计算

问题：通过进程调度示意图，计算设备利用率。

| 进程 | 10   | 20   | 30   | 40   | 50   | 60   | 70   | 80   | 90   | 100  |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| P1   | R2   | R2   | R2   | CPU  | R1   | R1   | R1   | CPU  |      |      |
| P2   | R1   | R1   | CPU  | Wait | CPU  | CPU  | R2   | R2   | R2   | R2   |
| P3   | CPU  | CPU  | Wait | Wait | Wait | Wait | CPU  | Wait | CPU  | R1   |

解：CPU 利用率 90%，R2 利用率 70%

## 5.操作系统的文件管理

### 5.1 文件类型分类（性质和用途）

- 系统文件
- 库文件
- 用户文件

### 5.2 文件类型分类（操作保护）

- 只读文件
- 可读可写文件
- 可执行文件

### 5.3 文件类型分类（使用情况）

- 临时文件
- 永久文件
- 档案文件

### 5.4 文件类型分类（用户观点）

- 普通文件
- 目录文件
- 特殊文件（设备驱动程序）

### 5.5 文件类型分类（物理存取结构）

- 顺序（连续）文件
- 链接文件
- 索引文件

### 5.6 文件类型分类（逻辑存储结构）

- 记录式文件
- 流式文件

### 5.7 文件的四级安全管理措施

- **系统级管理**：不允许未经核准的用户进入系统，防止他人非法使用系统中各类资源。主要方法有注册、登录、登录时限限制等。
- **用户级安全管理**：为用户分配文件访问权，包括对所有用户进行分类、为指定用户分配文件访问权等。
- **目录级安全管理**：与用户权限无关，主要工作是保护系统中的各种目录。规定只有系统核心才具有写目录的权利。当一用户试图访问一目录时，系统核心将对用户访问权和目录中的访问权进行比较，通过后才给予用户有效的访问权。
- **文件级安全管理**：通过系统管理员或文件主对文件属性的设置，来控制用户对文件的访问。如只读与隐藏属性的设置。用户对文件的访问，将由用户访问权、目录访问权限和文件属性三者的权限所确定。

### 5.8 文件的系统格式

- **FAT32 格式**：属于 Windows 平台的传统文件格式，兼容性很好，但它不支持 4GB 以上的文件。
- **NTFS 格式**：属于 Windows 平台应用最广泛的文件格式，能够支持大容量文件和超大分区，集合了很多高级的技术，其中包括长文件名、压缩分区、数据保护、恢复等。
- **exFAT 格式**：是 U 盘最好的选择，支持访问控制，能够增强台式机或笔记本和移动设备之间的互操作能力，是微软为 ROM 特地设计的文件系统格式。
- **ext 格式**：Linux 中最早的文件系统格式，由于在性能和兼容性上具有很多缺陷，现在已经很少使用。其后续版本为：ext2，ext3，ext4。
- **xfs 格式**：被业界称为最先进，最具有可升级性的文件系统技术。

## 6.操作系统的内存管理

### 6.1 内存管理的作用

- 内存管理的主要目的是解决多个用户（进程）使用主存的问题。主要功能包括分配和回收主存空间、提高主存利用率、扩充主存、对主存信息实现有效保护。

### 6.2 单一连续区管理

- 最简单的存储管理方式。采用这种方式时，内存被分为两个区域，一个系统区域，设置在内存低端，另一个为用户区，是除系统区外全部内存区域，提供给用户使用。在这种方式下，任何时刻主存储器中最多只能有一个作业。

## 7.分区式内存管理

### 7.1 固定分区存储管理

- 将内存划分若干个连续固定的区域，每一个分区只能分配给某一个进程使用。由于每一个分区只能分配给某一个进程使用，而该进程可能占不满这个分区，所以会有内部碎片。

![](/images/drawingbed/img/202306271940544.png)

### 7.2 动态分区存储管理

- 在运行时根据进程所需内存，动态分配一块连续的内存区域，每一个分区只能分配给某一个进程使用。由于要求进程占用一块连续的内存区域，当为所有进程分配内存后，总会有部分内存没有被分配到，此时就产生大量的外部碎片。

![](/images/drawingbed/img/202306271940176.png)

### 7.3 分区存储管理的优缺点

- 分区式管理时，进程的大小受分区大小或内存可用空间的限制
- 分区式管理不利于程序段和数据的共享

## 8.分页式内存管理

### 8.1 分页存储管理

- 页式管理将内存空间分成一个个大小相等的分区，每个分区就是一个页框。每一个页框有一个编号，称为页框号，从 0 开始。在分配内存时，将进程分割成和页框大小相等的一个个区域，也叫页，每一个页面有一个编号，叫做页号，从 0 开始。操作系统会以页框为单位，将每一个页面分别放入一个页框中。
- 注意：各个页面不需要连续存放，可以放到不相邻的各个页框中。

![](/images/drawingbed/img/202306271940546.png)

### 8.2 分页存储管理的优缺点

- 页式管理只在内存存放反复执行或即将执行的程序段与数据部分
- 不经常执行的程序段和数据存放于外存待执行时调入。

### 8.3 分页存储管理的逻辑地址计算

- 假如页号有 k 位，那么页面总数就是 2^k 个，`Len([10-19])`=10，即 2^10
- 假如页内地址 m 位，那么页面大小为 2^m，`Len([0-9])`=10，即 2^10

![](/images/drawingbed/img/202306271940725.png)

### 8.4 分页存储管理的物理地址换算

问题：某个分页系统，页面大小为 2K，即 2048 个字节。某一个作业有 4 个页面，分别装入到主存的第 3、4、6、8 块中。求逻辑地址 2500 对应的物理地址。

- 页号 = Int( 逻辑地址 / 页面大小 ) = 2500/2048 = 1（第1页）
- 页内地址 = 逻辑地址 mod 页面大小 = 2500%2048 = 452
- 产生页表：页面编号从 0 开始，分别对应物理块号有：编号 0 - 第 3 块，编号 1 - 第 4 块
- 物理地址 = 物理块号 X 页面大小 + 页内地址 = 3 X 2048 + 452 = 6596

## 9.分段式内存管理

### 9.1 分段存储管理

- 段式管理会根据程序自身的逻辑关系将进程划分为若干个段，每个段都有一个段名，每段从 0 开始编址。在内存分配时，以段为单位进行分配，每个段在内存中占连续空间，但各段之间可以不相邻。
- 对用户来说，分段是可见的，页是信息的物理单位，分页活动对用户不可见。页的大小固定，由系统决定，段的大小不固定，由用户决定。

![](/images/drawingbed/img/202306271941854.png)

### 9.2 分段存储管理的逻辑地址计算

- 分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成
- 假如段号占 k 位，则每个进程最多有 2^k 个，`Len([16-31])`= 16，即段数最大为 2^16 = 64K 个段
- 假如段内地址占 m 位，那么每个段最大长度为 2^m，`Len([0-15])`= 16，即段内地址最大长度 2^16 B = 64 KB

![](/images/drawingbed/img/202306271941184.png)

## 10.段页式内存管理

### 10.1 页式系统与段式系统的对比

![](/images/drawingbed/img/202306271941725.png)

### 10.2 段页式存储管理

- 通过对段内地址进行页式存储管理，组成段页式存储管理。用户程序按段式划分，按页式存储管理方案进行内存分配。
- 在这种存储管理系统中，处理器给出的有效地址被分为3个部分，即段号，页号和页内地址。

![](/images/drawingbed/img/202306271942125.png)

### 10.3 段页式存储管理的优缺点

- 这种技术的优点是提供了大量虚存空间，能有效地利用主存。
- 缺点是增加了硬件成本，系统复杂性和管理上的开销，并且页面使用不充分，各种表格占用主存空间。进行地址变换和实现靠拢操作要花费大量处理器时间。

### 10.4 段页式存储管理的逻辑地址计算

- 段号的位数决定每个进程**最多**可以分配多少个段。
- 页号的位数决定每个段**最大**有多少页。
- 页内地址决定页面的大小。

![](/images/drawingbed/img/202306271942516.png)

## 11.操作系统的硬盘管理

### 11.1 位示图

- 位示图，又叫位图，在外存中利用二进制中一位来表示磁盘中每一个盘块使用情况。当值为 0 时，表示对应的盘块空闲，为 1 时，表示已经分配。
- 在位示图中，1个位表示1个物理块的使用情况，因此按字节编码，若系统字长32位，则位示图中每1个字表示 32 个物理块的大小。
- 位示图占用字节数量(个) = 物理块总数 / 系统字长。

### 11.2 位示图的计算

问题：由系统字长 32 位，磁盘容量 1000GB，磁盘物理块大小 4 MB，编号物理块 0，1，2，位示图字 0，1，2，则 16385 号物理块的使用情况在位示图中第几个字中？位示图需要多少个字表示？

解：由于系统字长 32 位，因此 1 个字表示 32 个物理块，因此 16385/32 ~= 512 ..... 1，即第 16385 号物理块在第 513 个字中，又因为位示图字编号由 0 开始，因此第 16385 号物理块在位示图编号 512 的字中描述。因为磁盘容量为 1000 X 2^10 MB，每个物理块大小为 4 MB，因此物理块总数 1000 X 2^10 / 4 = 250 X 2^10 个，占用字节数量 = 250 X 2^10 / 32 = 250 X 32(2^5) = 8000 个。