---
title: 08软件工程
date: 2023-04-26
author: LM
---

## 软件工程概述

- **概念**：软件是计算机程序、规程、相关文档和数据的集合。软件工程是以软件质量为目标的一系列工程活动。
- **特性**：复杂性、不可见性、可变性、一致性。
- **三要素**：过程、方法和工具。
- **框架**：目标、过程和原则。
- **基本原则**：模块化，抽象，信息掩蔽。

## 软件生存周期

- 软件生命周期是软件产生到报废或停止使用的生命周期。
- 软件生命周期分为问题定义及规划、需求分析、系统设计、软件编程、软件测试、软件维护 6 个阶段。

## 软件定义阶段

- 完成从物理模型导出到逻辑模型的过程。需要跟用户交流，清楚要做什么样的系统，为了完成什么功能，建立目标系统的雏形。从现实环境出发，分析出可行方案，分别给出计划，从物理模型中抽象出逻辑模型，完成可行性报告。

- 在软件定义阶段需要完成如：问题定义，需求分析，可行性分析，项目计划制定，验收计划制定的任务。


## 可行性报告

- 经济可行性（投入，产出）
- 技术可行性（开发风险，资源可行性）
- 操作可行性（用户是否认可）
- 法律可行性
- 时间可行性

## 需求的类型

- **功能需求**：所开发的软件必须具备什么样的功能。
- **非功能需求**：是指产品必须具备的属性或品质，如可靠性、性能、响应时间、容错性和扩展性等。
- **设计约束**：也称为限制条件、补充规约，这通常是对解决方案的一些约束说明。

## 需求分析阶段

在这一步中，需要把上一步中抽象出的逻辑模型进行实例化，即确定系统必须完成哪些工作，对目标系统提出完整、准确、清晰、具体的要求。

- 把目标系统的逻辑模型进行分块。
- 深入描述软件的功能和性能。
- 考虑软件使用的限制条件。
- 定义软件的其他有效性需求。
- 产出【软件功能规格说明书】，说明书需要确定用户对软件的需求，作到明确、无歧义。不涉及具体实现方法。


## 需求分析方法

- **功能分解方法**：将新系统作为多功能模块的组合，各功能可分解为若干子功能及接口，子功能能继续分解。
- **结构化分析方法**：以自顶向下，逐步求精为基点，以数据流图，数据字典，结构化语言，判定表，判定树等图形表达为主要手段，强调开发方法的结构合理性和系统的结构合理性的软件分析方法。
- **信息建模方法**：从数据角度对现实世界建立模型。此方法的核心概念是实体和关系，基本工具是 E-R 图，其基本要素由实体、属性和联系构成。该方法的基本策略是从现实中找出实体，然后再用属性进行描述。
- **面向对象的分析方法**：识别问题域内的对象，分析它们之间的关系，并建立对象模型、动态模型和功能模型三类模型。考虑类或对象、结构与连接、继承和封装、消息通信等内容。

## 需求的特征

- **完整性**：每一项需求都必须将所要实现的功能描述清楚，使设计人员获得设计和实现这些功能所需的必要信息。
- **正确性**：每一项需求都必须准确地陈述其要开发的功能。（只有用户代表才能确定需求的正确性）
- **可验证性**：检查每一项需求是否能通过测试用例或其它验证方法。
- **可行性**：每一项需求都必须是在已知的系统或环境内可以实现的。（建立数学模型，进行仿真）
- **必要性**：每项需求都是编写文档的根源，每项需求都唔那个回溯到具体用户。（用户需求，跟踪矩阵，WishList）
- **无歧义性**：对所有的需求，读者只能有一个明确统一的解释。（形式化的语言、图、表）

## 需求分析工具

- 数据流图
- 数据字典
- 判定表
- 判定树

## 概要设计

概要设计的目的是将软件系统需求转换为未来系统的设计。重点说清楚总体实现方案，确定软件系统的总体布局，各个子模块的功能和模块间的关系，模块与外部系统的关系。

- 设计软件系统的总体结构，确定软件体系结构。
  - 将系统按功能划分模块；
  - 确定每个模块功能；
  - 确定模块间调用关系；
  - 确定模块间的接口；
  - 评价模块的质量；
- 数据整体结构和数据库设计。
- 编写概要设计文档，概要设计文档最重要的部分是分层数据流图、结构图、数据字典以及相应的文字说明等。
- 评审软件体系结构。

## 详细设计

依据概要设计阶段的分解，设计每个模块内的算法、流程等。

- 模块内部的数据结构设计。
- 模块内部的算法设计。

详细设计文档最重要的部分是模块的流程图、状态图、局部变量及相应的文字说明等。

## 结构设计原则

- 原则一：**价值为王**，不应该开发任何当前不使用的功能。因为这些占用开发成本的功能，可能根本没有人用。而且不仅仅是开发成本打了水漂，你还要不断投入维护成本，来保证这些无人使用的功能可以正常运行。

- 原则二：**以终为始**，在做事之前，先想想结果是什么样子的，这个结果是否能达到最初的目标。

- 原则三：**分治原则**，做架构时不要想着一次性把所有的功能都做好，要拥抱 MVP（Minimal Viable Product），最小可运行版本。先让程序完成最基本功能上线，根据反馈调整和决定下一步的迭代。迭代着去做事情，敏捷开发的思路。对于每个功能点，创建里程碑，然后去迭代。

- 原则四：**服务自治**，在系统设计时，要考虑服务上线后，对于问题要自感知、自修复、自优化、自运维及自安全。

- 原则五：**拥抱变化**，重视架构扩展性和可运维性。无状态的系统的是可扩展的和直接的。任何时候都要考虑这一点，不要搞个不可扩展的，有状态的东西出来。否则，一旦需要改变，成本很高。

- 原则六：**简单即正义**，保持每件事情都尽可能的简单。用最简单的解决方案来解决问题。

- 原则七：**尽量自动化**，人力成本既慢又贵，还有经常不断的人工失误。如果不能降低人力成本，反而需要更多的人，那么这个架构设计一定是失败的。

- 原则八：**依赖最简**，依赖原则是去除依赖、弱化依赖、控制依赖。多一个依赖多一分风险。能不依赖则不依赖，能异步弱依赖不要同步强依赖。实在不能弱依赖的，比如必须要调用加密存储来获取数据库的密码，不然无法连接数据库，可以控制获取密码在服务启动时进行。

- 原则九：**不作不死**，尽可能的做较少的功能。当有疑问的时候，就不要去做，甚至干掉。很多功能从来不会被使用。最多留个扩展点就够了。等到有人提出再说（除非是影响核心流程，否则就等到需要的时候再去做）。

- 原则十：**容灾容错**，如果一件事情有可能发生则在生产环境中一定会发生，架构中要做好容错设计。

- 原则十一：**用成熟的技术**，更多地使用主流大多数公司实际在用的技术栈。


## 模块设计原则

- 一个软件系统是由各个子系统构成的，子系统是由各个模块组成的。
- 模块设计的原则就是模块独立。
- 模块独立是指每个模块完成一个相对的特定子功能、并且与其他模块之间的联系简单。
- 衡量模块独立程度标准有两个：低耦合性、高内聚性。

## 耦合性

对象间的耦合度即对象间的依赖性，耦合性是程序结构中各模块间相互关联的度量，它取决于各模块间接口的复杂程序，调用模块的方式。耦合如下可分为七级，从低至高，耦合度应越低越好 。

- **非直接耦合**：两模块间彼此无任何交互，没有直接关系
- **数据耦合**：两模块间仅通过数据参数交换信息
- **标记耦合**：两模块间通过参数表传递记录信息，这个记录信息包含着复合数据结构，含有若干数据项
- **控制耦合**：两模块间传递的参数中含有控制信息
- **外部耦合**：两模块间共同访问一个全局简单变量，而不是全局数据结构
- **公共耦合**：指模块间存在着公共数据区、全局数据结构、可共享的文件
- **内容耦合**：一个模块需要使用另一模块内部的数据或控制信息的路径。包括以下情况：一个模块直接访问另一个模块；两个模块由一部分代码重叠；一个模块有多个入口。

## 内聚性

内聚是一个模块内部各成分相关联的度量，标志一个模块内各元素彼此结合的紧密程度。把内聚按紧密程度从低到高排列次序为偶然内聚、逻辑内聚、时间内聚、过程内聚、通信内聚、顺序内聚、功能内聚。但是紧密程度的增长是非线性的。偶然内聚和逻辑内聚的模块联系松散，后面几种内聚相差不多，功能内聚一个功能、独立性强、内部结构紧密，是最理想的内聚。

- **偶然内聚**：如果一个模块的各成分之间毫无关系，则称为偶然内聚，也就是说模块完成一组任务，这些任务之间的关系松散，实际上没有什么联系。
- **逻辑内聚**：几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。如一个模块读取各种不同类型外设的输入。尽管逻辑内聚比偶然内聚合理一些，但逻辑内聚的模块各成分在功能上并无关系，即使局部功能的修改有时也会影响全局，因此这类模块的修改也比较困难。
- **时间内聚**：如果一个模块完成的功能必须在同一时间内执行（如系统初始化），但这些功能只是因为时间因素关联在一起，则称为时间内聚。
- **过程内聚**：构件或者操作的组合方式是，允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递。模块完成多个需要按一定的步骤一次完成的功能。（过程相关---控制耦合）。例如：在用程序流程图设计模块时，若将程序流程图中的一部分划出各自组成模块，便形成过程内聚。
- **通信内聚（信息内聚）**：如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚。模块完成多个功能，各个功能都在同一数据结构上操作，这个模块的所有功能都是基于同一个数据结构（符号表），因此，它是一个信息内聚的模块。
- **顺序内聚**：模块内部的各部分，前一个部分处理的输出作为另一个部分的输入，则称为顺序内聚。
- **功能内聚**：模块的所有成分对于完成单一的功能都是必须的，则称为功能内聚。

## 结构化分析

结构化分析（Structured Analysis，简称SA）是指20世纪70年代末，由Demarco等人提出的，是面向数据流进行需求分析的方法，旨在减少分析活动中的错误，建立满足用户需求的系统逻辑模型。

结构化分析的要点是：根据软件内部数据传递、变换的关系，采用自顶向下，逐层分解的方法，经过一系列分解和抽象，建立系统的逻辑模型。结构化体现在将软件系统抽象为一系列的逻辑加工单元，各单元之间以数据流发生关联。

结构化方法总的指导思想是自顶向下、逐层分解，它的基本原则是功能的分解与抽象。是软件工程中最早出现的开发方法，特别适合于数据处理领域的问题，但是不适合解决大规模的、特别复杂的项目，且难以适应需求的变化。

## 结构化分析方法(输出)

- **数据流图**：描述系统由哪几部分组成，各部分之间有什么联系。
- **数据字典**：定义了数据流图中每一个图形元素。
- **加工结构**（结构化语言、判定表、判定树）：详细描述数据流图中不能被再分解的每一个加工。

## 结构化分析建模

- **数据流图（DFD）**：功能建模，其要素包括加工，数据流，是需求分析阶段的结果，是接口设计的依据
- **实体联系图（E-R）**：数据建模，其要素包括实体类型，属性和联系的方法，是描述现实世界的概念模型
- **状态-迁移图（STD）**：行为建模，其要素包括状态，改变状态的事件，用来描述系统的行为

## 结构化设计

![](/images/drawingbed/img/202307040937993.png)

注意：模块内部设计也称为"过程设计"

## 结构化设计原则

- 模块间应具有较强的独立性，高内聚，低耦合。
- 模块间的连接只能存在上下级关系，不能有同级间横向联系。
- 整个系统呈现树状结构，不允许网状结构或交叉调用关系。
- 所有模块必须严格分类编码并建立归档文件。

## 算法和数据结构设计

对算法设计时，主要依据加工规格说明来描述算法，可以使用流程图，伪代码，决策树来进行展示。

## 数据字典

数据字典是一个存放有数据库所用的有关信息，在数据库设计的初期将数据库中的各类数据的描述集合在一起，用于在开发，维护或者其他需要的时候使用，可以类比成我们现实中的字典。

数据字典通常包括：数据项，数据结构，数据流，数据存储，基本加工。其中数据项是数据的最小组成单位，若干个数据项可以组成一个数据结构。数据字典通过对数据项和数据结构的定义来描述数据流和数据存储的逻辑内容。

## 数据流图

- 数据流图（Data Flow Diagram），简称 DFD，它从数据传递和加工角度，以图形方式来表达数据在系统内部的逻辑流向和逻辑变换过程，是结构化系统分析方法的主要表达工具及用于表示软件模型的一种图示方法。
- 数据流图是接口设计的依据。
- 根据数据流动和处理的环节不同，数据流图可以拆分为四大要素
  - 外部实体：方框表示，指系统之外与系统有联系的人或事物，表示该系统数据的外部来源和去处。
  - 数据加工：椭圆表示，描述输入数据流到输出数据之间的变换，也就是输入数据流经过什么处理后变成了输出数据。
  - 数据存储：使用一组平行线表示，某种数据保存后的逻辑统称，不是指保存数据的物理地点和物理介质。每个数据存储都有一个名字。
  - 数据流：使用带箭头的曲线表示，处理功能的输入 / 输出，箭头表示数据流向。
- 数据流图具有抽象性，概括性的特征。
- 数据流图的平衡指父图和子图的输入，输出数据流的一致性
- 数据流图中加工的描述可以使用结构化语言，判定表和判定树
- 数据流图的注意事项：
  - 自外向内，自顶向下，逐层细化，完善求精
  - 保持父图与子图的平衡
  - 保持数据守恒
  - 加工细节隐藏
  - 简化加工间的关系
  - 均匀分解
  - 适当取名，避免空洞的名字
  - 表现的是数据流而不是控制流
  - 每个加工必须既有输入数据流，又有输出数据流

## 决策树

决策树适用于描述存在多个分支判断的系统。其是一种树形结构，其中每个内部节点表示一个属性上的测试，每个分支代表一个测试输出，每个叶节点代表一种类别。通过构成决策树来求取净现值的期望值大于等于零的概率，评价项目风险，判断其可行性的决策分析方法，是直观运用概率分析的一种图解法。

## 用例图

用例图是编写需求说明时经常用到的需求表达方式，用于向开发、测试同事说明需求中用户与系统功能单元之间的关系。它主要由三部分组成：参与者、用例、参与者与用例之间的关系。

- 参与者：不是特指人，是指系统以外的，在使用系统或与系统交互中所扮演的角色。因此参与者可以是人，可以是事物，也可以是时间或其他系统等等。
- 用例：是对包括变量在内的一组动作序列的描述，系统执行这些动作，并产生传递特定参与者的价值的可观察结果。
- 关系：参与者与用例之间的关系主要包括关联、归纳（泛化）、包含、拓展和依赖。

## 流程图

## 实体联系图（E-R图）

- 实体联系图是一种提供了实体，属性和联系的方法，用来描述现实世界的概念模型，表示在信息系统中概念模型的数据存储。
- 实体联系图常用于系统设计中的数据建模，用来表示实体与实体间的联系，不表现软件模块的执行过程。

## 状态图

## 软件开发模型

[一文讲清十大软件过程模型 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/379684828)

- **瀑布模型**：又称为经典生命周期模型。是一种线性过程流模型，一个阶段活动完成后再开始下一个阶段活动。
- **V 模型**：瀑布模型的一个变体，强调在各个阶段进行测试和验证，以提升软件质量。
- **原型模型**：通过构造原型，即一个软件系统的最初版本，用于验证概念、适用设计选型、发现更多的问题和可能的解决方法。原型是为定义需求服务的，在需求明确后，原型需要丢弃（至少部分丢弃）。
- **增量模型**：先开发出一个初始的实现，给用户使用并听取用户的使用意见，通过不断修改直到产生一个充分的版本。各活动不是分离而是交织在一起的。反应了我们解决问题的方法，我们很少能提前制定出完整的问题解决方案，而是摸着石头过河，逐步逼近结果。
- **螺旋模型**：一种风险驱动型的过程模型。吸收了瀑布模型和原型模型（演化模型）的优点。采用循环的方式逐步加深系统定义和实现的深度，同时降低风险。将过程（项目阶段）用螺旋线表示，每个螺旋线构成一个回路，每个回路由不同的风险驱动，根据这些风险，在每个阶段规划可选的策略方案。
- **喷泉模型**：一种以用户需求为动力，以对象为驱动的模型，主要用于描述面向对象的软件开发过程。该模型认为软件开发过程自下而上周期的各阶段是相互迭代和无间隙的。
- **RUP 统一过程模型**：一种用例驱动，以体系结构为核心，迭代及增量的软件过程框架，由UML方法和工具支持。它融合统一了瀑布模型、增量过程模型、演化过程模型、基于构建的开发、面向方面的软件开发这五种基本软件过程。RUP强调软件开发是一个迭代模型(Iterative Model)，它定义了四个阶段(Phase)：初始(Inception)、细化(Elaboration)、构造(Construction)、交付(Transition)。每个阶段都会在结束时产生一些制品。初启阶段结束时产生一个构想文档、一个有关用例模型的调查、一个初始的业务用例、一个早期的风险评估和一个可以显示阶段和迭代的项目计划等制品：精化阶段结束时产生一个补充需求分析、一个软件架构描述和一个可执行的架构原型等制品；构建阶段结束时的成果是一个准备交到最终用户手中的产品，包括具有最初运作能力的在适当的平台上集成的软件产品、用户手册和对当前版本的描述；移交阶段结束时产生移交给用户产品发布版本。
- **敏捷模型**：软件项目在构建初期被拆分为多个相互联系而又独立运行的子项目，然后迭代完成各个子项目，开发过程中，各个子项目都要经过开发测试。

## 瀑布模型

瀑布模型是将软件生存周期的各项活动规定为按固定顺序而连接的若干阶段工作，形如瀑布流水，最终得到软件产品。瀑布模型核心思想是按工序将问题化简，将功能的实现与设计分开，便于分工协作，即采用结构化的分析与设计方法将逻辑实现与物理实现分开。将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。

## 瀑布模型的优点

1. 为项目提供了按阶段划分的检查点。
2. 当前一阶段完成后，您只需要去关注后续阶段。
3. 每一个阶段提交的所有制品都需要进行评审和验证
4. 可在迭代模型中应用瀑布模型。增量迭代应用于瀑布模型。每次迭代产生一个可运行的版本,同时增加更多的功能。每次迭代必须经过质量和集成测试。
5. 它提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导。

## 瀑布模型的缺点

1. 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量。
2. 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险。
3. 通过过多的强制完成日期和里程碑来跟踪各个项目阶段。
4. 瀑布模型的突出缺点是不适应用户需求的变化。

## RUP 统一过程模型

## 敏捷方法

- **极限编程xp**：是激发开发人员创造性、使得管理负担最小的一组技术。
- **水晶法**：认为每一个不同的项目都需要一套不同的策略、约定和方法论。
- **并列争球法**：使用迭代的方法，其中把每30天一次的迭代成为一个冲刺，并按需求的优先级来实现产品。多个自组织和自治小组并行地递增实现产品，协调是通过简短的日常情况会议进行。
- **在自适应软件开发（ASD）**：有一个使命作为指导，它设立了项目的目标，但并不描述如何达到这个目标。

## 极限编程

极限编程是一个轻量级的、灵巧的软件开发方法；同时它也是一个非常严谨和周密的方法。它的基础和价值观是交流、朴素、反馈和勇气；即，任何一个软件项目都可以从四个方面入手进行改善：加强交流；从简单做起；寻求反馈；勇于实事求是。XP是一种近螺旋式的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期；通过积极的交流、反馈以及其他一系列的方法，开发人员和客户可以非常清楚开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。 极限编程鼓励从最简单的解决方式入手再通过不断重构达到更好的结果。这种方法与传统系统开发方式的不同之处在于，它只关注于对当前的需求来进行设计、编码，而不去理会明天、下周或者下个月会出现的需求。

## 极限编程 XR 的十二个最佳实践

1. 计划游戏（快速制定计划、随着细节的不断变化而完善）
2. 小型发布
3. 隐喻
4. 简单设计
5. 测试先行
6. 重构
7. 结对编程
8. 集体代码所有制
9. 持续集成
10. 每周工作40个小时
11. 现场客户
12. 编码标准 

## 软件复杂度

- 软件复杂度是理解和使用软件的难易程度。
- 度量标准有：规模，难度，结构，智能度。

## 软件体系风格

软件体系结构风格（Architectural Styles）是描述特定系统组织方式的惯用范例，强调了软件系统中通用的组织结构。一个软件体系结构风格定义了构件和连接件类型的符号集，及规定了它们怎样组合起来的约束集合。

- **数据流风格**：批处理序列，管道/过滤器
- **调用/返回风格**：主程序/子程序，面向对象，层次结构
- **独立构建风格**：进程通讯，事件系统
- **虚拟机风格**：解释器，基于规则的系统
- **仓库风格**：数据库系统，超文本系统，黑版系统

## 调用/返回风格

**主程序-子程序风格**：是结构化程序设计的一种典型风格，从功能的观点设计系统，通过逐步分解和细化，形成整个系统的体系结构。

**面向对象风格**：与前面的主程序-子程序风格比，面向对象风格中的构件变成了对象，并且连接的方式也发生了相应的变化。

- 强调设计，全面的系统考虑，和现实世界的对应关系
- 对象对客户隐藏了实现的细节，可以在不影响客户的情况下改变对象的实现(低耦合，高重用，可维护)，方便系统升级
- 内部表达的保护(封装数据/状态的完整)
- 对象交互时需要知道彼此的标识
- 多个对象对同一资源的访问(A和B同时需要使用C)可能对出现问题
- 体系结构设计，分解出的构件很难做到对象这么精准

**分层的体系风格**：组织为层次结构，每一层给外层提供服务，又作为它内层的客户；某些系统中，内层只对相邻的层可见。组织间通过连接件（层间的协议）定义层次间的交互方式

- 支持基于抽象程度逐渐递增的系统设计
- 支持层重用
- 支持功能增强
- 高扩展性，可维护性
- 行为改变难以进行传递
- 上面的层过分依赖下面的层提供服务，相关数据传达时间长，数据传输低效
- 层次大小的难以清晰界定
- 缺少公认合适的、正确的层次抽象方法。

## 数据流风格

**管道-过滤器风格**：把系统任务分成若干连续的处理步骤，这些步骤由通过系统的数据流连接，一个步骤的输出是下一个步骤的输入。

- 使得软构件具有良好的隐蔽性和高内聚、低耦合的特点，系统中已有的过滤器很容易用于新的待设计系统
- 允许设计者将整个系统的输入/输出行为看成是多个过滤器的行为的简单合成
- 支持软件重用。重要提供适合在两个过滤器之间传送的数据，任何两个过滤器都可被连接起来
- 系统维护简单。容易进行扩展
- 支持并行执行。每个过滤器是作为一个单独的任务完成，因此可与其它任务并行执行
- 为系统的性能分析提供了方便
- 由于过滤器是对输入的批量转换处理，对输入和输出有相应的说明限制，通常会导致进程成为批处理的结构
- 全局变量的共享很困难，通信、交互性不强
- 当数据传输量很大而又有很多小的过滤器时代价较大
- 执行效率并不理想，交互性差
- 出现错误时如何做处理比较困难

## 仓库风格

**仓库体系风格**：以数据为中心的体系结构，适合于数据由一个模块产生而由其他模块使用的情形。

- 能在有限的范围内实验不同的问题解决者和诱导启发式的控制方法
- 知识源可以重用；规模伸缩性好（方便添加新数据）
- 系统在有限的范围内可以容忍哪些不可靠的问题解决者，这可以通过保护/修改黑板实现
- 测试困难，难以保障最佳解决方案
- 控制策略通常需要启发诱导
- 计算开销大（工作量可能比较大，浪费多）
- 增加了系统的复杂度
- 数据修改困难

## 设计模式

设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。采用设计模式能复用相似问题的相同解决方案。

## 设计模式的三大类

- **创建型模式（Creational Pattern）**：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。

  **（5种）单例模式、工厂模式、抽象工厂模式、建造者构建模式、原型模式**

- **结构型模式（Structural Pattern）**：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。

  **（7种）适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式**

- **行为型模式（Behavioral Pattern）**：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。

  **（11种）策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式**

## 设计模式的UML类图

[ 23种设计模式 UML 类图图解 ](https://blog.csdn.net/qq_40274514/article/details/124047443)

## MVC 设计模式

MVC 模型-视图-控制器是一种设计模式，它强制性地使应用程序的输入，处理和输出分开，使应用程序分为模型，视图，控制器 3 个模块，各自处理自己的任务。

- **视图**：用户看到并与之交互的界面。
- **模型**：企业数据和业务规则，应用程序的核心业务逻辑。
- **控制器**：接受用户输入并调用模型和视图完成用户需求，控制器本身不输出任何内容并执行任何处理，只是接受请求并调用其他模式。
- **MVC 的优点**：耦合性低；重用性高；部署快，生命周期成本低；可维护性高；
- **MVC 的缺点**：运行效率低；调试困难；不适合小型，中等规模的应用程序；增加系统结构和实现的复杂性；视图与控制器间的过于紧密的连接并且降低了视图对模型数据的访问；

## 软件配置管理

软件配置管理，又称软件形态管理、或软件建构管理，简称软件形管（SCM）。界定软件的组成项目，对每个项目的变更进行管控（版本控制），并维护不同项目之间的版本关联，以使软件在开发过程中任一时间的内容都可以被追溯。其内容主要包括以下三个部分：

- **版本控制**
- **变更控制**
- **过程支持**

软件开发项目中，往往使用配置库来实现变更控制，其流程包括：

- 一般情况下，处于开发状态中的软件配置项尚未稳定下来，并未受到配置管理的控制，开发人员的变更也并未受到限制，软件配置项处于**自由状态**；
- 但当开发人员认为工作已告完成，可供其他配置项使用时，它就开始趋于稳定。把它交出评审，就开始进入**评审状态**；
- 若通过评审作为基线将准许进入配置库（实施check-in），开始“冻结”，此时开发人员不允许对其任意修改，因为它已处于**受控状态**；
- 通过评审表明，它确已达到质量要求，但若未能通过评审，则将其回归到工作状态，重新进行调整。

软件配置管理的关键活动包括：

- **配置项标识**
- **工作空间管理**
- **配置项控制 ( 版本控制、变更控制 )** 
- **配置项状态报告**
- **配置审计**

## 基线

指的是已经通过正式评审和批准的某规约或产品，因此它可以作为进一步开发的基础，并且只能通过正式的变更控制规程被改变。软件配置管理中有三个基线概念：功能基线、分配基线和产品基线。

- **功能基线**指在系统分析与软件定义阶段结束时，经过正式评审和批准的系统设计规格说明，功能基线是最初批准的功能配置标识；
- **分配基线**指在软件需求分析阶段结束时，经过正式评审和批准的软件需求规格说明。分配基线是最初批准的分配配置标识；
- **产品基线**指在软件组装与系统测试阶段结束时，经过正式评审和批准的有关软件产品的全部配置项的规格说明，产品基线是最初批准的产品配置标识。

## 软件测试配置管理

- 测试活动的配置管理属于整个软件项目配置管理的一部分
- 软件测试配置管理包括6个基本的活动：建立配置计划，配置标识和建立基线，配置变更管理，版本管理，配置审计，配置状态报告
- 配置项变更控制要规定测试基线，对每个基线进行描述
- 配置状态报告要确认过程记录、跟踪问题报告、更改请求以及更改次序等

## 软件质量

软件质量就是“软件与明确地和隐含地定义的需求相一致的程度”。更具体地说，软件质量是软件与明确地叙述的功能和性能需求、文档中明确描述的开发标准以及任何专业开发的软件产品都应该具有的隐含特征相一致的程度。

## 软件质量的标准

1. 软件需求是度量软件质量的基础，与需求不一致就是质量不高。除了显性需求外，隐含需求还应满足，否则软件的质量仍然是值得怀疑的。
2. 指定的标准定义了一组指导软件开发的准则，如果没有遵守这些准则，几乎肯定会导致质量不高。

## 软件质量评审内容

- 功能结构
- 功能通用性
- 模块层次
- 硬件接口

## QA 与 QC 

- **QA**：Quality Assurance，质量保证 
- **QC**：Quality Control，质量控制

## 影响软件的质量因素

1. **产品运行**：正确性，健壮性，效率，完整性，可用性，风险
2. **产品修改**：可理解性，可维修性，灵活性，可测试性
3. **产品转移**：可移植性，可再用性，互运行性

## ISO9126软件质量特性

软件质量特性(是指)的定义与有关产品，过程或体系的固有特性，主要包括以下 6 种：

- **功能性**：软件实现的功能满足用户要求
- **可靠性**：软件在稳定状态下能维持正常工作
- **易用性**：软件与用户间的友善性，用户在使用软件时的方便程度
- **效率**：耗费物理资源的有效程度
- **可维护性**：在环境改变或发生错误时修改的难易程度
- **可移植性**：软件能方便地移植到不同运行环境的程度

## CMM 能力成熟度模型

CMM 能力成熟度模型是一种用于评价软件承包能力并帮助其改善软件质量的方法，侧重于软件开发过程的管理及工程能力的提高与评估。CMM分为五个等级：一级为初始级，二级为可重复级，三级为已定义级，四级为已管理级，五级为优化级。

1. **初始级(initial)**。工作无序，项目进行过程中常放弃当初的计划。管理无章法，缺乏健全的管理制度。开发项目成效不稳定，项目成功主要依靠项目负责人的经验和能力，他一旦离去，工作秩序面目全非。
2. **可重复级(Repeatable)**。管理制度化，建立了基本的管理制度和规程，管理工作有章可循。 初步实现标准化，开发工作比较好地按标准实施。 变更依法进行，做到基线化，稳定可跟踪，新项目的计划和管理基于过去的实践经验，具有复现以前成功项目的环境和条件。
3. **已定义级(Defined)**。开发过程，包括技术工作和管理工作，均已实现标准化、文档化。建立了完善的培训制度和专家评审制度，全部技术活动和管理活动均可控制，对项目进行中的过程、岗位和职责均有共同的理解 。
4. **已管理级(Managed)**。产品和过程已建立了定量的质量目标。开发活动中的生产率和质量是可量度的。已建立过程数据库。已实现项目产品和过程的控制。可预测过程和产品质量趋势，如预测偏差，及时纠正。
5. **优化级(Optimizing)**。可通过采用新技术、新方法，集中精力改进过程。具备防缺陷、识别薄弱环节以及改进的手段。可取得过程有效性的统计数据，并可据此进行分析，从而得出最佳方法。

## TMM 软件测试能力成熟度模型

- 初始级。
- 阶段定义级。
- 集成级。
- 管理和度量级。
- 优化，预防缺陷和质量控制级。

## 风险分析

风险分析在软件项目中具有重要作用，包括风险识别，风险预测，风险评估和风险控制等。

- **在风险识别过程中**，要识别潜在的预算，进度，个体，资源，用户和需求等方面对整个项目的影响，并建立风险条码检查表列出所有可能的风险事项。
- **在风险预测过程中**，要建立一个表示风险可能性的参考标准，描述风险条目的结果，并估计影响。
- **在风险评估过程中**，对资产所面临的威胁、存在的弱点、造成的影响，以及三者综合作用所带来风险的可能性的评估。量化测评某一事件或事物带来的影响或损失的可能程度。
- **在风险控制过程中**，指风险管理者采取各种措施和方法，消灭或减少风险事件发生的各种可能性，或风险控制者减少风险事件发生时造成的损失。

## UML

统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何具体程序设计语言。

UML分为结构体和行为图：

- **结构体**包括类图，组合结构体，构件图，部署图和对象图
- **行为图**包括活动图，顺序图，通信图，交互概况图，时序图，用例图与状态图。

## UML 类图

类在类图中用矩形框表示，矩形框分为三层：第一层是类名字。第二层是类的成员变量；第三层是类的方法。成员变量以及方法前的访问修饰符用符号来表示：

- `+` 表示 `public`
- `-` 表示 `private`
- `#` 表示 `protected`
- 不带符号表示 `default`

![](/images/drawingbed/img/202307040938481.png)

**抽象类**在UML类图中同样用矩形框表示，但是抽象类的类名以及抽象方法的名字都用斜体字表示。

![](/images/drawingbed/img/202307040938953.png)

**接口**在类图中也是用矩形框表示，但是与类的表示法不同的是，接口在类图中的第一层顶端用构造型 `<<interface>>`表示，下面是接口的名字，第二层是方法。此外，接口还有另一种表示法，俗称棒棒糖表示法，就是类上面的一根棒棒糖（圆圈+实线）。圆圈旁为接口名称，接口方法在实现类中出现。

![](/images/drawingbed/img/202307040938512.png)

类和接口一般都出现在**包**中，UML类图中包的表示形式如图4所示。

![](/images/drawingbed/img/202307040939794.png)

**实现关系**是指接口及其实现类之间的关系。在UML类图中，实现关系用空心三角和虚线组成的箭头来表示，从实现类指向接口。

![](/images/drawingbed/img/202307040939446.png)

**泛化关系**（Generalization）是指对象与对象之间的继承关系。如果对象A和对象B之间存在继承关系，对象B是父对象，对象A是子对象。在UML类图中，泛化关系用空心三角和实线组成的箭头表示，从子类指向父类。

![](/images/drawingbed/img/202307040939988.png)

**关联关系**（Association）是指对象和对象之间的连接，它使一个对象知道另一个对象的属性和方法。在代码中，关联关系表现为一个对象含有另一个对象的引用。也就是说，如果一个对象的类代码中，包含有另一个对象的引用，那么这两个对象之间就是关联关系。关联关系有单向关联和双向关联。如果两个对象都知道（即可以调用）对方的公共属性和操作，那么二者就是双向关联。如果只有一个对象知道（即可以调用）另一个对象的公共属性和操作，那么就是单向关联。大多数关联都是单向关联，单向关联关系更容易建立和维护，有助于寻找可重用的类。在UML图中，双向关联关系用带双箭头的实线或者无箭头的实线双线表示。单向关联用一个带箭头的实线表示，箭头指向被关联的对象。

![](/images/drawingbed/img/202307040939813.png)

**依赖**（Dependency）关系是一种弱关联关系。如果对象A用到对象B，但是和B的关系不是太明显的时候，就可以把这种关系看作是依赖关系。。比如驾驶员和汽车的关系，驾驶员使用汽车，二者之间就是依赖关系。在UML类图中，依赖关系用一个带虚线的箭头表示，由使用方指向被使用方，表示使用方对象持有被使用方对象的引用。

![](/images/drawingbed/img/202307040939906.png)

**聚合**（Aggregation）是关联关系的一种特例，它体现的是整体与部分的拥有关系，即 has a 的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享，所以聚合关系也常称为共享关系。例如，公司部门与员工的关系，一个员工可以属于多个部门，一个部门撤消了，员工可以转到其它部门。在UML图中，聚合关系用空心菱形加实线箭头表示，空心菱形在整体一方，箭头指向部分一方。

![](/images/drawingbed/img/202307040940071.png)

**组合**（Composition）也是关联关系的一种特例，它同样体现整体与部分间的包含关系，即 contains a 的关系。但此时整体与部分是不可分的，部分也不能给其它整体共享，作为整体的对象负责部分的对象的生命周期。这种关系比聚合更强，也称为强聚合。如果`A`组合`B`，则`A`需要知道`B`的生存周期，即可能`A`负责生成或者释放`B`，或者`A`通过某种途径知道`B`的生成和释放。例如，人包含头、躯干、四肢，它们的生命周期一致。当人出生时，头、躯干、四肢同时诞生。当人死亡时，作为人体组成部分的头、躯干、四肢同时死亡。在UML图中，组合关系用实心菱形加实线箭头表示，实心菱形在整体一方，箭头指向部分一方。

![](/images/drawingbed/img/202307040940827.png)

## UML 类图中的关系

- **实现**：类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约。
- **依赖**：两个事物间的语义关系，其中一个事物发生变化会影响另一个事物的语义。
- **继承**：一种特殊/一般关系，特殊元素对象可替代一般元素对象。
- **关联**：一种结构关系，描述一组链，链是对象间的联系。
- **聚合**：一种特殊的类型关联，是整体和部分的拥有关系。
- **组合**：一种特殊的类型关联，是整体和部分的包含关系。

## UML 类图的应用场景

- 对系统的词汇建模。
- 对简单的协作建模。
- 对逻辑数据库模式建模。

## 软件维护

- **正确性(更正性)维护**：更正交付后发现的错误。
- **适应性维护**：是软件产品能够在变化后或变化中的环境中继续使用。
- **完善性维护**：改进交付后产品性能和可维护性。
- **预防性维护**：在软件产品的潜在错误成为实际错误前，检测并进行更正。

## 可维护性复审

- 在完成了每项维护工作之后，都应该对软件维护本身进行仔细认真的复审。
- 在软件再次交付使用之前，对软件配置进行严格的复审，则可大大减少问题。
- 在需求/系统分析阶段的复审过程中，应该对将来要改进的部分和可能会修改的部分加以注意并指明；应该讨论软件的可移植性问题，并且考虑可能影响软件维护的系统界面。
- 在系统设计阶段的复审过程中，应该从容易修改、模块化和功能独立的目标出发，评价软件的结构和过程，对将来可能修改的部分预作准备。
- 在系统实施阶段的复审期间，代码复审应该强调编码风格和内部说明文档这两个影响可维护性的因素。

## 软件开发文档

- 软件开发文档可分为开发，管理和用户文档。
- 开发文档应当包括软件需求说明，可行性研究报告和项目开发计划。
- 文档是影响软件可维护性的决定因素。由于长期使用的大型软件系统在使用过程中必然会经受多次修改，所以文档比程序代码更重要。软件文档应该满足下述要求：

  - 必须描述如何使用这个系统，没有这种描述时即使是最简单的系统也无法使用。
  - 必须描述怎样安装和管理这个系统。
  - 必须描述系统需求和设计。
  - 必须描述系统的实现和测试，以便使系统成为可维护的。

## 重构

系统发展到一定阶段后，使用重构的方式，不改变系统的外部功能，只对内部的结构进行重新的整理。通过重构，不断的调整系统的结构，使系统对于需求的变更始终具有较强的适应能力。重构可以降低项目的耦合度，使项目更加模块化，有利于项目的开发效率和后期的维护。让项目主框架突出鲜明，给人一种思路清晰，一目了然的感觉，其实重构是对框架的一种维护。

## 更多资料

[一文讲清十大软件过程模型 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/379684828)

[软件工程——瀑布模型、快速原型模型、增量模型、螺旋模型_原型模型和增量模型的区别_「已注销」的博客-CSDN博客](https://blog.csdn.net/zjuwxx/article/details/97252039)

[23种设计模式UML类图图解_设计模式类图_路漫漫路漫漫的博客-CSDN博客](https://blog.csdn.net/qq_40274514/article/details/124047443)

[快速记忆23种设计模式 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/128145128)